#+HTML_HEAD: -*- fill-column: 92 -*-

#+TITLE: Модуль HeadHunter

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

TODO: Обсудить все нижеследующее с hr-специалистами

* Введение

  Мы все ищем работу на профильных сайтах, но, к сожалению, не всегда на них хватает
  функционала, особенно нестандартного. Работая с сайтом в автоматическом режиме мы можем
  восполнить этот пробел.

  Кроме того есть множество конкурирующих сайтов для поиска работы, информацию с которых
  можно аггрегировать.

  При поиске работы основной сценарий использования - поиск вакансий, и практически все
  сайты его предоставляют. Однако мне бы хотелось дополнительно иметь:
  - функционал заметок по каждой вакансии
  - статусы, такие как: =просмотрено= (с датой), =отобрано=, =не-берут-трубку=,
    =не-актуально=, =приглашен-на-интервью=, =тестовое-задание=, =получен-оффер=,
    =отказано-работодателем=, =отказ-соискателя=, =вакансия-снята= итп. Более подробно это
    уточняется в секции [[Вакансии]]

  Я бы хотел ранжировать вакансии вручную (по выставленным приоритетам) и автоматически,
  например в зависимости от зарплаты или удаленности от дома.

  В идеале я бы хотел иметь возможность планировать маршрут, когда еду на собеседование и
  иметь календарь, чтобы не пропустить встречу.

  Я бы хотел иметь версии вакансий, чтобы отслеживать их изменения, например изменения
  зарплаты до и после моего интервью - это позволит анализировать рынок и получать больше
  информации.

  Мне также интересно составлять профили компаний и отслеживать как меняется набор
  сотрудников которых они ищут - это поможет планировать долгосрочную стратегию. Особенно в
  этом плане интересны лидеры рынка - Яндекс, Гугл и.т.п.

  Почему сайты поиска работы не предоставляют подобный сервис для соискателей - для меня
  загадка и повод подумать над стартапом :) Кстати похожие кейсы наверное есть и в
  покупке/продаже автотранспорта или барахолках типа авито.

  Позже можно добавить социальный шаринг всего этого дела, чтобы любой соискатель мог
  рассказать о своем опыте взаимодействия с потенциальным работодателем.

  Иногда мне приятно работать с уже знакомыми людьми, так что в целом я бы не отказался
  создавать на таком сайте что-то типа т.н. =рабочих коллективов=, чтобы наниматься сразу
  командой. Возможно работодателям такой вариант найма тоже будет интересен.

* Сценарии использования

  Зарегистрированный пользователь создает "поисковый профиль", в который заносит поисковый
  запрос и (в будущем) источники данных. Поля профиля описаны в секции [[Поисковые профили]].

  Потом он планирует сбор данных. Пока сбор будет осуществляеться по запросу, позже можно
  будет запланировать, к примеру "еженедельный сбор"

  Система осуществляет сбор данных и предоставляет пользователю интерфейс доступа к ним

  Пользователь просматривает, дополняет изменяет данные, вносит заметки, звонит по вакансиям
  и отражает это в данных.

** Поисковые профили и сбор данных

   Чтобы у нас были данные, с которыми мы собираемся работать - их надо откуда-то
   собрать, например, с профильных сайтов, таких как http://hh.ru

   Разумеется, лучше собирать не все подряд, а только то что необходимо соискателю. Когда
   соискатель пользуется профильным сайтом он использует поисковые запросы, на основании
   которых мы можем формировать, гм... назовем это =поисковыми профилями=. Поисковый
   профиль - это запрос пользователя, плюс связанные с ним данные - назовем их =сборками=.

   Сборки по одному поисковому профилю могут осуществляться в разное время. Они часто
   интересны тем, что можно посмотреть как появляются и исчезают вакансии. В каждой сборке
   содержится набор =вакансий=, при этом одни и те же по сути вакансии в разных сборках
   связываются между собой, чтобы можно было отслеживать изменения вакансии с течением
   времени.

   Вакансии на сайтах размещаются =компаниями= и привязываются к ним. Мне, как соискателю,
   интересно посмотреть какие вакансии размещала ранее конкретная компания, какие она
   размещает теперь, как изменялись зарплаты - и тому подобная аналитическая информация.

   Загрузка данных начинается с автоматического использования поиска. Мне интересны разные
   поисковые запросы - например, "веб-программист", "менеджер проекта", "руководитель
   отдела" и.т.п. По каждому из них можно составить поисковый профиль, который кроме текущих
   актуальных вакансий в нем содержит еще и "сборки" - с датой и временем получения данных и
   "изменения", т.е диффы между предыдущей сборкой и этой. Таким образом, например, можно
   отслеживать только что появляющиеся вакансии, которые часто представляют наибольший
   интерес.

   Мне бы хотелось осуществлять =сбор данных в многопоточном режиме=.

** Поиск вакансий

   Внутри вакансий необходимо искать по критериям, которые я уточню позже

   Мне хотелось бы чтобы вакансии были упорядочены по зарплате

   Мне бы хотелось сразу получать представление, насколько свежая вакансия

   Мне было бы интересно, сколько интервью было проведено и запланировано по вакансии - эту
   информацию можно узнать из анализа активности по ней других пользователей

   Мне было бы интересно, как менялась вакансия с момента ее размещения компанией - можно
   находить и отслеживать похожие вакансии по расстоянию Левенштейна в описании, к
   примеру. Динамика изменения зарплатного предложения может многое сказать об отношении к
   вакансии.

** Просмотр и отбор вакансий, заметки и выставление статусов

   Когда я читаю вакансию, я бы хотел, чтобы она переходила в статус "просмотрено" (и к ней
   добавлялась дата просмотра)

   Читая вакансию, мне бы хотелось устанавливать ей приоритет и вносить заметки, чтобы
   отслеживать такие моменты, как например: необходимость позвонить позже, или все, что мне
   сказал hr по телефону. Есть типовые вещи, которые можно просто сделать кнопками.

   Если я отправляю отзыв на вакансию или звоню по телефону - я бы хотел, чтобы эти действия
   сопровождались временем и изменением статуса, чтобы потом можно было отследить историю
   взаимодействия с фирмой.

   При этом, мне хотелось бы видеть на дашборде те вакансии, с которыми я договорился о
   встрече и те, по которым нет движения долгое время, чтобы ничего не забывалось.

** Дашборд

   Если у нас есть формализованный алгоритм (а он есть, так как найм - это линейный
   процесс), то я хочу получать напоминания о моем следующем шаге в отношении тех вакансий,
   которые мне интересны.

   Мне бы хотелось видеть на каком я этапе в тех вакансиях, которые меня интересуют.

** Отзывы соискателей о компаниях и вакансиях

   Можно сэкономить кучу времени и денег просто не нанимаясь в те компании, в которых "все
   плохо". В этом плане соискатели могут помоч друг другу. Возможно и компании тоже будут
   прислушиваться к такому фидбеку

** Размещение резюме

   Пользователь просто размещает свое резюме. На самом деле - несколько резюме, так как
   наиболее продвинутые пользователи пишут резюме под вакансию, а не рассылают одно и то же
   резюме всем подряд

** Маршрут

   Иногда я хочу спланировать маршрут поездки по собеседованиям. Это сервис с картами,
   которые можно сделать позже.

* Сущности
** Поисковые профили

   #+CAPTION: Данные поискового профиля
   #+NAME: profile_flds
     | field name   | field type | note                                      |
     |--------------+------------+-------------------------------------------|
     | id           | serial     | идентификатор                             |
     | user-id      | integer    | владелец и создатель                      |
     | search-query | varchar    | поисковый запрос                          |
     | ts-create    | bigint     | время создания                            |
     | ts-last      | bigint     | время когда был использован последний раз |

   #+NAME: create_profiles
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defparameter *profile-all*
       (make-profile :name "Все вакансии программистов"
                     :user-id 1
                     :search-query "http://spb.hh.ru/search/vacancy?area=2&text=&salary=&currency_code=RUR&specialization=1.221"
                     :ts-create (get-universal-time)
                     :ts-last (get-universal-time)))
   #+END_SRC

** Сборки

   Сборка создается по запросу пользователя в состоянии =sheduled=. Это происходит в секции
   [[Интерфейс планирования сбора данных]]

   После сбора данных сборка переходит в состояние =executed= и ее данные становятся
   доступны для просмотра

   #+CAPTION: Данные сборки
   #+NAME: collection_flds
     | field name | field type | note                             |
     |------------+------------+----------------------------------|
     | id         | serial     | идентификатор                    |
     | profile-id | integer    | поисковый профиль                |
     | ts-create  | bigint     | время создания                   |
     | ts-shedule | bigint     | время когда сборка запланирована |

   #+CAPTION: Состояния конечного автомата сборки
   #+NAME: collection_state
     | action         | from     | to          |
     |----------------+----------+-------------|
     | sheduled       | sheduled | executed    |

   #+NAME: create_collections
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defparameter *collection-all*
       (make-collection :profile-id (id *profile-all*)
                        :ts-create (get-universal-time)
                        :ts-shedule (get-universal-time)
                        :state :sheduled))
   #+END_SRC

** Вакансии

   #+CAPTION: Данные вакансии
   #+NAME: collection_flds
     | field name    | field type | note                                                        |
     |---------------+------------+-------------------------------------------------------------|
     | id            | serial     | идентификатор                                               |
     | collection-id | integer    | идентификатор сборки                                        |
     | contact       | varchar    | телефон контактного лица                                    |
     | salary        | integer    | размер компенсации                                          |
     | text          | varchar    | описание вакансии                                           |
     | history       | varchar    | список изменения статусов со временем каждого изменения     |
     | reason        | varchar    | добавляем причину действия (позже ссылка на другую таблицу) |
     | ts-created    | bigint     | время создания вакансии                                     |
     | ts-viewed     | bigint     | время когда вакансия была просмотрена                       |

   TODO: Конечный автомат тут сложен и будет еще уточняться... Пока состояния такие:
    =просмотрено= (с датой), =отобрано=, =не-берут-трубку=, =не-актуально=,
    =приглашен-на-интервью=, =тестовое-задание=, =получен-оффер=, =отказано-работодателем=,
    =отказ-соискателя=, =вакансия-снята= итп.

   С точки зрения соискателя процесс найма выглядит так (неплохо бы приложить временную
   схему протокола):

   - Этап поиска
     - Поиск и просмотр вакансий, отсев, ранжирование
     - Рассылка откликов
   - Этап телефонных переговоров
     - Получение звонков, обсуждение деталей по телефону
     - Опционально: договоренность о еще одном звонке
     - Опционально: тестовое задание на почту
     - Опционально: договоренность о skype-интервью
   - Этап удаленного тестирования
     - Skype-интервью
     - Ожидание тестового задания
     - Выполнение тестового задания
   - Этап очного собеседования
     - Приглашение на интервью
     - Интервью
   - Этап отбора предложений
     - Получение предложений
     - Выбор предложения

   Вакансия создается в состоянии "новая" - =new=. После просмотра пользователем вакансия
   автоматически переходит в состояние "просмотрена" - =viewed=. Однако пользователь может
   перевести ее обратно в состояние =new= если ему так захотелось.

   Если пользователю вакансия не нравится он может выкинуть ее, чтобы больше к ней не
   возвращаться, после чего она становится =hidden=. Однако пользователь может передумать и
   тогда ему нужно предоставлять корзину выкинутых вакансий, чтобы он мог ее восстановить. В
   таком случае нам нужно помнить предыдущий статус выкинутой вакансии.

   Если вакансия пользователю понравилась - он может отправить отклик через форму (TODO:
   создать таблицу откликов, чтобы пользователь мог просто выбрать среди них, а не печатать
   одно и то же для каждой вакансии). После посылки отклика (если она прошла успешно)
   вакансия переходит в состяние "отклик послан" - =responded=.

   Если пользователь просмотрел вакансию, но пока не хочет отправлять отзыв - он может
   добавить вакансию в закладки - в этом случае ее статус меняется на =favorited=

   Из =favorited= мы снова можем отправить отзыв.

   Из =favorited= пользователь может вернуть вакансию обратно в =viewed= или выкинуть

   Если по вакансии позвонили, пользователю обычно нужно ее быстро найти. Нужна форма поиска
   по вакансиям в статусе =responded= - пользователь ищет обычно по названию фирмы.

   После звонка вакансия может быть выкинута или переведена из =responded= в статус "был
   телефонный звонок" - =called=. Выкидывая вакансию пользователь может выбрать reason - для
   них можно будет потом сделать отдельную таблицу но пока просто пишем в поле
   вакансии. Если в результате телефонного звонка была достигнута договоренность о
   собеседовании - пользователь переводит вакансию в состояние "пригласили на интервью" -
   =wait-interview= и заносит в вакансию данные о том, куда и во сколько ехать. Если по
   телефону рекрутер предложил тестовое задание - статус - "ожидание тестового задания" -
   =wait-test=. Если договорились о интервью по скайпу - "ожидание скайп-интервью" -
   =wait-skype-interview=.

   Получив тестовое задание пользователь переводит вакансию из статуса =wait-test= в
   "выполнение тестового задания" =run-test=, а оттуда либо в =test-cancel= либо в
   =test-sended=. Либо выкидывает.

   Пользователи иногда забивают на интервью (случаются накладки) - в этом случае рекрутер
   часто передоговаривается на другое время. Делать петли в графе значит излишне усложнять
   его, наверно пусть можно будет просто изменить данные о времени интервью.

   После интервью или скайп-интервью от вакансии можно либо отказаться (=refuse-employer=,
   =refuse-applicant=) либо перевести в статус "ожидание результата" - =wait-result=. Нужно
   включать таймер, по истечении которого напоминать пользователю позвонить рекрутеру и
   узнать, как дела.

   Иногда после скайп-интервью назначают очное интервью. Также бывает прямо на интервью
   предлагают оффер - =offer= и соискатель берет время на подумать.

   Из "ожидания результата" можно перескочить в "предложен оффер", "отказ работодателя" -
   =refuse-employer= или "отказ соискателя" - =refuse-аpplicant=.

   История статусов нужна, в нее нужно заносить время когда изменяется статус и возможно
   примечания по изменению. Будет красиво, если в интерфейсе будет отображаться полный граф
   статусов и текущее положение вакансии в нем.

   #+CAPTION: Состояния конечного автомата мотоцикла
   #+NAME: vacancy_state
     | action                                 | from                 | to                   |
     |----------------------------------------+----------------------+----------------------|
     | view                                   | new                  | viewed               |
     | renew                                  | viewed               | new                  |
     | hide-after-view                        | viewed               | hidden               |
     | restore-from-hidden-to-view            | hidden               | viewed               |
     | send-respond-from-view                 | viewed               | responded            |
     | favor                                  | viewed               | favorited            |
     | send-respond-from-favorited            | favorited            | responded            |
     | unfavor                                | favorited            | viewed               |
     | hide-after-favor                       | favorited            | hidden               |
     | call                                   | responded            | called               |
     | invite-interview                       | called               | wait_interview       |
     | invite-skype-interview                 | called               | wait_skype_interview |
     | invite-test                            | called               | wait_test            |
     | interview                              | wait_interview       | interview            |
     | skype-interview                        | wait_skype_interview | skype_interview      |
     | call-after-skype-interview             | skype_interview      | called               |
     | execute-test                           | wait_test            | run_test             |
     | send-test                              | run_test             | send_test            |
     | called-after-test                      | send_test            | called               |
     | refuse-employer-after-interview        | interview            | refuse_employer      |
     | refuse-applicant-after-interview       | interview            | refuse_applicant     |
     | wait-result-after-interview            | interview            | wait_result          |
     | refuse-employer-after-skype-interview  | skype_interview      | refuse_employer      |
     | refuse-applicant-after-skype-interview | skype_interview      | refuse_applicant     |
     | wait-result-after-skype-interview      | skype_interview      | wait_result          |
     | invite-next-interview                  | wait_result          | interview            |
     | invite-interview-after-skype           | skype_interview      | interview            |
     | invite-offer                           | wait_result          | offer                |
     | employer-refuse-after-wait-result      | wait_result          | refuse_employer      |
     | applicant-refuse-after-wait-result     | wait_result          | refuse_applicant     |

   Теперь мы можем полностью описать поведение вакансии как конечный автомат:

   #+NAME: vacancy_state_graph
   #+BEGIN_SRC emacs-lisp :var table=vacancy_state :results output :exports none
     (mapcar #'(lambda (x)
                 (princ (format "%s -> %s [label =\"%s\"];\n"
                                (second x) (third x) (first x))))
             table)
   #+END_SRC

   #+BEGIN_SRC dot :file img/vacancy-state.png :var input=vacancy_state_graph :exports results
     digraph G {
       rankdir = LR;
       $input
     }
   #+END_SRC

** TODO Перекрестные связи с другими вакансиями

   В ряде случаев компании меняют свои вакансии, некоторые делают это методом удаления
   предыдущей и создания новой. Мне как соискателю хотелось бы не обнаруживать уже
   просмотренную и возможно собеседованную вакансию в новых. Поэтому хотелось бы
   предусмотреть механизм, который связывает очень похожие вакансии друг с другом.

   Иногда вакансии меняются, или в них меняются существенные условия. Например, две недели
   назад, когда я смотрел вакансию из предыдущей сборки меня не устроила зарпалата, а
   сегодня вакансия стала интереснее. Я хочу отслеживать что вакансия поменялась.

** Компании

   Несколько вакансий могут быть от одной компании. В этом случае мне бы хотелось
   отслеживать это в профиле компании, кроме того интересна аналитика по этой компании за
   определенный период времени.

   С социальной точки зрения интересно получать отзывы о компании от ее работников, в том
   числе и уволенных.

** Действия по вакансии: звонки, скайп-интервью, собеседования

   В эту таблицу заносим что сделано по каждой вакансии, которая находится в разработке

** Теги вакансий

   Помогают ориентироваться, когда вакансий много.

* Interface

  Соберем веб-интерфейс:

  #+NAME: iface
  #+BEGIN_SRC lisp :tangle src/mod/hh/iface.lisp :noweb tangle :exports none :padline no :comments link
    ;;;; iface.lisp

    (in-package #:moto)

    ;; Страницы
    <<iface_contents>>
  #+END_SRC

** Дашборд
** TODO Интерфейс планирования сбора данных
* Тесты

  #+NAME: hh_test
  #+BEGIN_SRC lisp :noweb tangle :exports none

    ;; Тестируем hh
    (defun hh-test ()
      <<hh_test_contents>>
      (dbg "passed: hh-test~%"))
    (hh-test)
  #+END_SRC

  #+NAME: hh_test_contents
  #+BEGIN_SRC lisp :noweb tangle :exports none

  #+END_SRC
* Точки входа

  Соберем шаблоны:

  #+NAME: hh_tpl
  #+BEGIN_SRC closure-template-html :tangle src/mod/hh/hh-tpl.htm :noweb tangle :exports none
    // -*- mode: closure-template-html; fill-column: 140 -*-
    {namespace hhtpl}

    <<hhtpl_contents>>
  #+END_SRC

  Скомпилируем шаблоны при подготовке модуля

  #+NAME: hh_prepare
  #+BEGIN_SRC lisp :tangle src/mod/hh/hh-prepare.lisp :noweb tangle :exports none
    (in-package #:moto)

    ;; Скомпилируем шаблон
    (closure-template:compile-template
     :common-lisp-backend
     (pathname
      (concatenate 'string *base-path* "mod/hh/hh-tpl.htm")))
  #+END_SRC

  Соберем контроллеры и все функции, которые контроллеры вызывают

  #+NAME: hh_fn
  #+BEGIN_SRC lisp :tangle src/mod/hh/hh.lisp :noweb tangle :exports none
    (in-package #:moto)

    <<flat_entity>>

    <<hh_fn_contents>>

    <<hh_test>>
  #+END_SRC

* Сборка
** Утилиты

   #+NAME: utility_file
   #+BEGIN_SRC lisp :tangle src/mod/hh/util.lisp :noweb tangle :exports code  :padline no :comments link
     (in-package #:moto)

     (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0")

     (defparameter *cookies*
       (list "portal_tid=1291969547067-10909"
             "__utma=189530924.115785001.1291969547.1297497611.1297512149.377"
             "__utmc=3521885"))

     (setf *drakma-default-external-format* :utf-8)

     (defun get-headers (referer)
       `(
         ("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
         ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
         ("Accept-Charset" . "utf-8")
         ("Referer" . ,referer)
         ;; ("Cookie" . ,(format nil "~{~a; ~}" *cookies*))
         ("Cookie" . "ad20c=2; ad17c=2; __utma=48706362.2093251633.1396569814.1413985658.1413990550.145; __utmz=48706362.1413926450.142.18.utmcsr=vk.com|utmccn=(referral)|utmcmd=referral|utmcct=/im; email=avenger-f%40yandex.ru; password=30e3465569cc7433b34d42baeadff18f; PHPSESSID=ms1rrsgjqvm3lhdl5af1aekvv0; __utmc=48706362; __utmb=48706362.5.10.1413990550")
         ))

     (defmacro web (to ot)
       (let ((x-to (append '(format nil) to))
             (x-ot (append '(format nil) ot)))
         `(let ((r (sb-ext:octets-to-string
                    (drakma:http-request ,x-to
                                         :user-agent *user-agent*
                                         :additional-headers (get-headers ,x-ot)
                                         :force-binary t)
                    :external-format :utf-8)))
            r)))

     (defmacro fnd (var pattern)
       `(multiple-value-bind (all matches)
            (ppcre:scan-to-strings ,pattern ,var)
          (let ((str (format nil "~a" matches)))
            (subseq str 2 (- (length str) 1)))))
   #+END_SRC

** Сущности и автоматы

   Соберем все сущности и автоматы

   #+NAME: entity_and_automates
   #+BEGIN_SRC lisp :tangle src/mod/hh/entityes.lisp :noweb tangle :exports none :padline no :comments link
     (in-package #:moto)

     <<asm_profile()>>

     <<create_profiles>>

     <<asm_collection>>

     <<create_collections>>

   #+END_SRC

** Поисковые профили

    #+NAME: asm_profile
    #+BEGIN_SRC emacs-lisp :var flds=profile_flds :exports none
      (gen-entity "profile" "поисковые профили" flds)
    #+END_SRC

** Сборки

    #+NAME: asm_collection
    #+BEGIN_SRC emacs-lisp :var flds=collection_flds states="collection_state" :exports none
      (gen-automat "collection" "сборки" flds states)
    #+END_SRC
