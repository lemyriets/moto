#+HTML_HEAD: -*- fill-column: 92 -*-

#+TITLE: Модуль HeadHunter

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

TODO: Обсудить все нижеследующее с hr-специалистами

* Введение

  Мы все ищем работу на профильных сайтах, но, к сожалению, не всегда на них хватает
  функционала, особенно нестандартного. Работая с сайтом в автоматическом режиме мы можем
  восполнить этот пробел.

  Кроме того есть множество конкурирующих сайтов для поиска работы, информацию с которых
  можно аггрегировать.

  При поиске работы основной сценарий использования - поиск вакансий, и практически все
  сайты его предоставляют. Однако мне бы хотелось дополнительно иметь:
  - функционал заметок по каждой вакансии
  - статусы, такие как: =просмотрено= (с датой), =отобрано=, =не-берут-трубку=,
    =не-актуально=, =приглашен-на-интервью=, =тестовое-задание=, =получен-оффер=,
    =отказано-работодателем=, =отказ-соискателя=, =вакансия-снята= итп. Более подробно это
    уточняется в секции [[Вакансии]]

  Я бы хотел ранжировать вакансии вручную (по выставленным приоритетам) и автоматически,
  например в зависимости от зарплаты или удаленности от дома.

  В идеале я бы хотел иметь возможность планировать маршрут, когда еду на собеседование и
  иметь календарь, чтобы не пропустить встречу.

  Я бы хотел иметь версии вакансий, чтобы отслеживать их изменения, например изменения
  зарплаты до и после моего интервью - это позволит анализировать рынок и получать больше
  информации.

  Мне также интересно составлять профили компаний и отслеживать как меняется набор
  сотрудников которых они ищут - это поможет планировать долгосрочную стратегию. Особенно в
  этом плане интересны лидеры рынка - Яндекс, Гугл и.т.п.

  Почему сайты поиска работы не предоставляют подобный сервис для соискателей - для меня
  загадка и повод подумать над стартапом :) Кстати похожие кейсы наверное есть и в
  покупке/продаже автотранспорта или барахолках типа авито.

  Позже можно добавить социальный шаринг всего этого дела, чтобы любой соискатель мог
  рассказать о своем опыте взаимодействия с потенциальным работодателем.

  Иногда мне приятно работать с уже знакомыми людьми, так что в целом я бы не отказался
  создавать на таком сайте что-то типа т.н. =рабочих коллективов=, чтобы наниматься сразу
  командой. Возможно работодателям такой вариант найма тоже будет интересен.

* Сценарии использования

  Зарегистрированный пользователь создает "поисковый профиль", в который заносит поисковый
  запрос и (в будущем) источники данных. Поля профиля описаны в секции [[Поисковые профили]].

  Потом он запрашивает сбор данных по этому поисковому профилю. Собираются тизеры
  вакансий. Если появились новые вакансии они добавляются в набор. Изменившиеся вакансии
  обновляются и помечаются как обновившиеся, не изменившиеся - не попадают в набор.

  После сбора данных пользователь просматривает набор и фильтрует его, отсеивая неинтересные
  вакансии, (которые скрываются) и помечая особенно понравившиеся (звездочкой).

  После фильтрации у отобранных вакансий скачиваются описания

  Выбрав вакансию, пользователь может оставить к ней заметки и начинает движение по графу состояний.

** Поисковые профили и сбор данных

   Чтобы у нас были данные, с которыми мы собираемся работать - их надо откуда-то
   собрать, например, с профильных сайтов, таких как http://hh.ru

   Разумеется, лучше собирать не все подряд, а только то что необходимо соискателю. Когда
   соискатель пользуется профильным сайтом он использует поисковые запросы, на основании
   которых мы можем формировать, гм... назовем это =поисковыми профилями=. Поисковый
   профиль - это запрос пользователя, плюс набор связанных с ним вакансий=.

   Вакансии на сайтах размещаются =компаниями= и привязываются к ним. Мне, как соискателю,
   интересно посмотреть какие вакансии размещала ранее конкретная компания, какие она
   размещает теперь, как изменялись зарплаты - и тому подобная аналитическая информация.

   Загрузка данных начинается с автоматического использования поиска. Мне интересны разные
   поисковые запросы - например, "веб-программист", "менеджер проекта", "руководитель
   отдела" и.т.п. По каждому из них можно составить поисковый профиль, который кроме текущих
   актуальных вакансий в нем содержит еще и "сборки" - с датой и временем получения данных и
   "изменения", т.е диффы между предыдущей сборкой и этой. Таким образом, например, можно
   отслеживать только что появляющиеся вакансии, которые часто представляют наибольший
   интерес.

   Мне бы хотелось осуществлять =сбор данных в многопоточном режиме=.

** Парсинг данных

   Они размещаются постранично, по 20 штук на странице, и мы можем собрать все страницы,
   если будем получать страницу за страницей, пока не получим страницу, на которой вакансий
   нет. Для того чтобы это реализовать нам нужно уметь получить страницу
   (=hh-get-page(url)=) и разобрать тизеры вакансий (=hh-parse-vacancy-teasers(html)=).

   Начнем с того, что будем собирать все ит-вакансии с http://spb.hh.ru

   Как только у нас это есть - код становится простым

   #+NAME: hh_parse
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defparameter *programmin-and-development-profile*
       (make-profile :name "Программирование и разработка"
                     :user-id 1
                     :search-query "http://spb.hh.ru/search/vacancy?clusters=true&specialization=1.221&area=2&page=~A"
                     :ts-create (get-universal-time)
                     :ts-last (get-universal-time)))

     (defun run-collect (profile)
       (let* ((search-str   (search-query profile))
              (all-teasers  nil))
         (block get-all-hh-teasers
           (loop :for num :from 0 :to 100 :do
              (print num)
              (let* ((url (format nil search-str num))
                     (teasers (hh-parse-vacancy-teasers (hh-get-page url))))
                (if (equal 0 (length teasers))
                    (return-from get-all-hh-teasers)
                    (setf all-teasers (append all-teasers teasers)))))
           (print "over-100"))
         all-teasers))

     (defparameter *teasers* (run-collect *programmin-and-development-profile*))

     (length *teasers*)

     (defun save-collect (all-teasers)
       (loop :for tea :in *teasers* :do
          (print tea)
          (make-vacancy :profile-id (id *programmin-and-development-profile*)
                        :name (getf tea :vacancy-name)
                        :rem-id (getf tea :vacancy-id)
                        :rem-date (getf tea :vacancy-date)
                        :rem-employer-name (getf tea :employer-name)
                        :rem-employer-id (aif (getf tea :employer-id)
                                              it
                                              0)
                        :currency (getf tea :salary-currency)
                        :salary (aif (getf tea :salary-base)
                                     it
                                     0)
                        :salary-text (getf tea :salary-text)
                        :state ":TEASER"
                        )))

     (save-collect *teasers*)
   #+END_SRC

*** Получение страниц

    Вот так мы можем получать страницы:

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun hh-get-page (url)
        "Получение страницы"
        (flexi-streams:octets-to-string
         (drakma:http-request url
                              :user-agent "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:34.0) Gecko/20100101 Firefox/34.0"
                              :additional-headers `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
                                                    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
                                                    ("Accept-Charset" . "utf-8")
                                                    ("Referer" . "http://spb.hh.ru/")
                                                    ("Cookie" . "redirect_host=spb.hh.ru; regions=2; __utma=192485224.1206865564.1390484616.1410378170.1417257232.29; __utmz=192485224.1390484616.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _xsrf=85014f262b894a1e9fc57b4b838e48e8; hhtoken=ES030IVQP52ULPbRqN9DQOcMIR!T; hhuid=x_FxSYWUbySJe1LhHIQxDA--; hhrole=anonymous; GMT=3; display=desktop; unique_banner_user=1418008672.846376826735616")
                                                    ("Cache-Control" . "max-age=0"))
                              :force-binary t)
         :external-format :utf-8))
    #+END_SRC

*** Разбор тизеров вакансий

    Теперь, чтобы получить вакансии с этой страницы - вырежем таблицу с ними и воспользуемся
    парсером, который переведет полученный html в более удобный лисп-список. Этот список
    содержит строки таблицы, которые бывают четырех видов:
    - премиум вакансии
    - разделитель между блоками премиум и обычных вакансий
    - обычные вакансии
    - обычный вакансии плюс.

    Нас интересуют все типы кроме разделителя, внутри они устроены сходно. При обработке
    строк интересующих типов мы получаем:
    - название вакансии
    - идентификатор (ссылку)
    - дату размещения
    - название работодателя
    - идентификатор работодателя

    Если в вакансии указана зарплата, мы также получаем
    - Валюту зарплаты (3х-буквенный идентификатор)
    - Сумму
    - Текстовое выражение, содержащее "от" или "от и до"

    Иногда HeadHunter синдицирует вакансии с других платформ, к примеру с CAREER.RU, тогда в
    вакансии может отсутствовать работодатель. Мы явно отрабатываем этот момент.

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun hh-parse-vacancy-teasers (html)
        "Получение списка вакансий из html"
        (let* ((cut (ppcre:scan-to-strings
                     (format nil "~A(.*)~A"
                             "<table class=\"l-table entry-content\" data-qa=\"vacancy-serp__results\">"
                             "<div class=\"g-hidden b-select-icon-popup HH-VacancyToFavorite-LimitPopup\">")
                     html))
               (cut-without-tail (subseq cut 0 (- (length cut) 74)))
               (parsed (html5-parser:node-to-xmls (html5-parser:parse-html5-fragment cut-without-tail)))
               (rows   (cddr (nth 2 (car parsed)))))
          (remove-if
           #'null
           (loop :for row :in rows :collect
              (when (or (ppcre:scan-to-strings "vacancy-serp__vacancy_premium" (car (cdaadr row)))
                        (string= "b-vacancy-list-standard" (car (cdaadr row)))
                        (string= "b-vacancy-list-standard_plus" (car (cdaadr row))))
                (let* ((data (nth 3 row))
                       (hh-vacancy-a (cdr (caddr (caddr (caddr (caddr data))))))
                       (hh-vacancy-name (car (last hh-vacancy-a)))
                       (hh-vacancy-id (parse-integer (car (last (split-sequence:split-sequence #\/ (car (cdaddr (car hh-vacancy-a)))))) :junk-allowed t))
                       (hh-vacancy-date (caddr (cadddr (caddr data))))
                       (hh-vacancy-placetime (nth 4 (nth 4 (caddr data))))
                       (hh-salary-div (nth 5 (caddr data)))
                       (result (list :vacancy-name hh-vacancy-name
                                     :vacancy-id hh-vacancy-id
                                     :vacancy-date hh-vacancy-date
                                     )))
                  (when hh-vacancy-placetime
                    (let ((hh-employer-name (car (last hh-vacancy-placetime)))
                          (hh-employer-id (parse-integer (car (last (split-sequence:split-sequence #\/ (car (cdaadr hh-vacancy-placetime))))) :junk-allowed t)))
                      (setf result (append result (list :employer-name hh-employer-name
                                                        :employer-id hh-employer-id)))))
                  (when (and hh-salary-div
                             (string= "b-vacancy-list-salary"  (car (cdaadr hh-salary-div))))
                    (let ((hh-salary-currency (cadr (cadadr (caddr hh-salary-div))))
                          (hh-salary-base (parse-integer (cadr (cadadr (cadddr hh-salary-div))) :junk-allowed t))
                          (hh-salary-text (car (last hh-salary-div))))
                      (setf result (append result (list :salary-currency hh-salary-currency
                                                        :salary-base hh-salary-base
                                                        :salary-text hh-salary-text)))))
                  result))))))
    #+END_SRC

*** Разбор вакансий

    Чтобы эффективнее (с точки зрения скорости написания кода) разбирать вакансии) мы
    разберем всю полученную страницу в список, который из которого извлечем необходимые нам
    элементы сопоставлением с образцом.

    Чтобы проходить по дереву, сопоставляя узлы с функцией-предикатом, в которую
    скомпилируется образец, напишем функцию parse-match. Она содержит в себе рекурсивную
    внутреннюю функцию, которая выполняет работу до тех пор пока не обнаружит в дереве
    элемент, совпадающий с образцом. Обнаружив, она выполняет возврат из внешней функции.

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun parse-match (par func)
        (defun in-parse-match (par func)
          (cond ((null par) nil)
                ((atom par) #|(print par)|#)
                (t (if (funcall func par)
                       (return-from parse-match par)
                       (progn
                         (in-parse-match (car par) func)
                         (in-parse-match (cdr par) func))))))
        (in-parse-match par func))
    #+END_SRC

    Это уже можно использовать вот таким образом:

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defparameter *test* (hh-parse-vacancy (hh-get-page "http://spb.hh.ru/vacancy/12325429")))

      (print
       (parse-match *test*
            #'(lambda (x)
                (handler-case
                    (destructuring-bind (a ((b c)) &rest d)
                        x
                      (aif (and (string= a "div")
                                (string= c "b-vacancy-custom g-round"))
                           it))
                  (sb-kernel::arg-count-error nil)
                  (sb-kernel::defmacro-bogus-sublist-error nil)))))
    #+END_SRC

    Но для удобной работы этого недостаточно, поэтому напишем компилер шаблона в
    соответствующий ему предикат. Этот компилер будет макросом, принимающим в качестве
    параметра форму, которая будет связываться с элементами шаблона с помощью
    =destructuring-bind=. Попытка связывания будет провоиться для каждого элемента дерева,
    ошибки которые возникают в случае невозможности связывания игнорируются.

    После того, как совпадающий с образцом элемент дерева будет найден, я хотел бы иметь
    возможность работать с составляющими его элементами. Это можно обеспечить, если предикат
    будет записывать в создаваемые глобальные переменные компоненты шаблона.

    Чтобы это обеспечить, мы используем внутренний макрос =binder=, который превращает
    шаблон вида =(a ((b c)) d &rest e)= в код вида:

    #+BEGIN_SRC lisp
      (PROGN
        (SETF **A** A)
        (SETF **B** B)
        (SETF **C** C)
        (SETF **D** D)
        (SETF **E** E))
    #+END_SRC

    Там где будет раскрываться этот макрос переменные =A B C D E= определены посредством
    =destructuring-bind=. Таким образом мы инжектируем переменные шаблона в глобальную
    область видимости.

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defmacro binder (varlist)
        (let ((result))
          (defun in-binder-linearizer (par)
            (cond ((null par) nil)
                  ((atom par) (cond ((equal par '&rest) nil)
                                    (t (setf result (append result (list par))))))
                  (t (progn
                       (in-binder-linearizer (car par))
                       (in-binder-linearizer (cdr par))))))
          (in-binder-linearizer varlist)
          `(progn
             ,@(mapcar #'(lambda (x)
                           `(setf ,(intern (format nil "**~A**" (symbol-name x))) ,x))
                       result))))

      ;; (macroexpand-1
      ;;  '(binder (a ((b c)) d &rest e)))

      (defmacro compile-pattern ((pattern) &body constraints)
        `#'(lambda (x)
             (handler-case
                 (destructuring-bind ,pattern
                     x
                   (aif (and ,@constraints)
                        (progn
                          (binder ,pattern)
                          it)))
               (sb-kernel::arg-count-error nil)
               (sb-kernel::defmacro-bogus-sublist-error nil))))

      ;; (macroexpand-1 '(compile-pattern ((a ((b c)) d &rest e))
      ;;                  (string= a "div")
      ;;                  (string= c "title b-vacancy-title")))

    #+END_SRC

    Теперь мы можем использовать это более простым и понятным образом

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (print
       (parse-match *test* (compile-pattern ((a ((b c)) &rest d))
                             (string= a "div")
                             (string= c "b-vacancy-custom g-round"))))

      ;; => '("div" (("class" "b-vacancy-custom g-round"))
      ;;      ("meta" (("itemprop" "title") ("content" "Ведущий android-разработчик")))
      ;;      ("h1" (("class" "title b-vacancy-title")) "Ведущий android-разработчик")
      ;;      ("table" (("class" "l"))
      ;;       ("tbody" NIL
      ;;        ("tr" NIL
      ;;              ("td" (("colspan" "2") ("class" "l-cell"))
      ;;                    ("div" (("class" "employer-marks g-clearfix"))
      ;;                           ("div" (("class" "companyname"))
      ;;                                  ("a" (("itemprop" "hiringOrganization") ("href" "/employer/1529644"))
      ;;                                       "ООО Нимбл"))))
      ;;              ("td" (("class" "l-cell")))))))

      (print **c**)
      ;; => "b-vacancy-custom g-round"
    #+END_SRC

    Теперь когда у нас есть необходимые инструменты, переходим к практической части. Мы
    должны извлечь несколько блоков:
    - блок заголовка
    - общие данные, такие как уровень зарплаты, город, требуемый опыт работы
    - собственно описание вакансии
    Из каждого блока будем извлекать конкретные данные, возвращаемы как plist

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)


      (defun hh-parse-vacancy (html)
        "Получение вакансии из html"
        (let* ((parsed (html5-parser:node-to-xmls (html5-parser:parse-html5-fragment html)))
               (header (parse-match parsed (compile-pattern ((a ((b c)) &rest d))
                                             (string= c "b-vacancy-custom g-round"))))
               (summary (parse-match parsed (compile-pattern ((a ((b c)) &rest d))
                                              (string= c "b-important b-vacancy-info"))))
               (infoblock (parse-match parsed (compile-pattern ((a ((b c)) &rest d))
                                                (string= c "l-content-2colums b-vacancy-container"))))
               (h1 (parse-match header (compile-pattern ((a ((b c)) title &rest archive-block))
                                         (print e)
                                         (string= c "title b-vacancy-title"))))
               (name **title**)
               (archive (if (car (last (car **archive-block**))) t nil))
               (employerblock (parse-match header (compile-pattern ((a ((b c) (d lnk)) emp))
                                                    (string= c "hiringOrganization"))))
               (employer-name **emp**)
               (employer-id (parse-integer (car (last (split-sequence:split-sequence #\/ **lnk**))) :junk-allowed t)))
          employer-id))

      (print
       (hh-parse-vacancy (hh-get-page "http://spb.hh.ru/vacancy/12321429")))

      (print
       (hh-parse-vacancy (hh-get-page "http://spb.hh.ru/vacancy/12325429")))


          ;; (remove-if
          ;;  #'null
          ;;  (loop :for row :in rows :collect
          ;;     (when (or (ppcre:scan-to-strings "vacancy-serp__vacancy_premium" (car (cdaadr row)))
          ;;               (string= "b-vacancy-list-standard" (car (cdaadr row)))
          ;;               (string= "b-vacancy-list-standard_plus" (car (cdaadr row))))
          ;;       (let* ((data (nth 3 row))
          ;;              (hh-vacancy-a (cdr (caddr (caddr (caddr (caddr data))))))
          ;;              (hh-vacancy-name (car (last hh-vacancy-a)))
          ;;              (hh-vacancy-id (parse-integer (car (last (split-sequence:split-sequence #\/ (car (cdaddr (car hh-vacancy-a)))))) :junk-allowed t))
          ;;              (hh-vacancy-date (caddr (cadddr (caddr data))))
          ;;              (hh-vacancy-placetime (nth 4 (nth 4 (caddr data))))
          ;;              (hh-salary-div (nth 5 (caddr data)))
          ;;              (result (list :vacancy-name hh-vacancy-name
          ;;                            :vacancy-id hh-vacancy-id
          ;;                            :vacancy-date hh-vacancy-date
          ;;                            )))
          ;;         (when hh-vacancy-placetime
          ;;           (let ((hh-employer-name (car (last hh-vacancy-placetime)))
          ;;                 (hh-employer-id (parse-integer (car (last (split-sequence:split-sequence #\/ (car (cdaadr hh-vacancy-placetime))))) :junk-allowed t)))
          ;;             (setf result (append result (list :employer-name hh-employer-name
          ;;                                               :employer-id hh-employer-id)))))
          ;;         (when (and hh-salary-div
          ;;                    (string= "b-vacancy-list-salary"  (car (cdaadr hh-salary-div))))
          ;;           (let ((hh-salary-currency (cadr (cadadr (caddr hh-salary-div))))
          ;;                 (hh-salary-base (parse-integer (cadr (cadadr (cadddr hh-salary-div))) :junk-allowed t))
          ;;                 (hh-salary-text (car (last hh-salary-div))))
          ;;             (setf result (append result (list :salary-currency hh-salary-currency
          ;;                                               :salary-base hh-salary-base
          ;;                                               :salary-text hh-salary-text)))))
          ;;         result))))))

          (defparameter *header* '("div" (("class" "b-vacancy-custom g-round"))
                                   ("meta"
                                    (("itemprop" "title") ("content" "Senior QA Automation (SELENIUM + C#)")))
                                   ("h1" (("class" "title b-vacancy-title"))
                                    "Senior QA Automation (SELENIUM + C#)"
                                    ("span" (("class" "archive__flag")) "Вакансия в архиве"))
                                   ("table" (("class" "l"))
                                    ("tbody" NIL
                                     ("tr" NIL
                                           ("td" (("colspan" "2") ("class" "l-cell"))
                                                 ("div" (("class" "employer-marks g-clearfix"))
                                                        ("div" (("class" "companyname"))
                                                               ("a" (("itemprop" "hiringOrganization") ("href" "/employer/69961"))
                                                                    "DataArt"))))
                                           ("td" (("class" "l-cell"))))))))
    #+END_SRC


** Поиск вакансий

   Внутри вакансий необходимо искать по критериям, которые я уточню позже

   Мне хотелось бы чтобы вакансии были упорядочены по зарплате

   Мне бы хотелось сразу получать представление, насколько свежая вакансия

   Мне было бы интересно, сколько интервью было проведено и запланировано по вакансии - эту
   информацию можно узнать из анализа активности по ней других пользователей

   Мне было бы интересно, как менялась вакансия с момента ее размещения компанией - можно
   находить и отслеживать похожие вакансии по расстоянию Левенштейна в описании, к
   примеру. Динамика изменения зарплатного предложения может многое сказать об отношении к
   вакансии.

** Просмотр и отбор вакансий, заметки и выставление статусов

   Когда я читаю вакансию, я бы хотел, чтобы она переходила в статус "просмотрено" (и к ней
   добавлялась дата просмотра)

   Читая вакансию, мне бы хотелось устанавливать ей приоритет и вносить заметки, чтобы
   отслеживать такие моменты, как например: необходимость позвонить позже, или все, что мне
   сказал hr по телефону. Есть типовые вещи, которые можно просто сделать кнопками.

   Если я отправляю отзыв на вакансию или звоню по телефону - я бы хотел, чтобы эти действия
   сопровождались временем и изменением статуса, чтобы потом можно было отследить историю
   взаимодействия с фирмой.

   При этом, мне хотелось бы видеть на дашборде те вакансии, с которыми я договорился о
   встрече и те, по которым нет движения долгое время, чтобы ничего не забывалось.

** Дашборд

   Если у нас есть формализованный алгоритм (а он есть, так как найм - это линейный
   процесс), то я хочу получать напоминания о моем следующем шаге в отношении тех вакансий,
   которые мне интересны.

   Мне бы хотелось видеть на каком я этапе в тех вакансиях, которые меня интересуют.

** Отзывы соискателей о компаниях и вакансиях

   Можно сэкономить кучу времени и денег просто не нанимаясь в те компании, в которых "все
   плохо". В этом плане соискатели могут помоч друг другу. Возможно и компании тоже будут
   прислушиваться к такому фидбеку

** Размещение резюме

   Пользователь просто размещает свое резюме. На самом деле - несколько резюме, так как
   наиболее продвинутые пользователи пишут резюме под вакансию, а не рассылают одно и то же
   резюме всем подряд

** Маршрут

   Иногда я хочу спланировать маршрут поездки по собеседованиям. Это сервис с картами,
   которые можно сделать позже.

** Создание вакансии работодателем
** Вакансия становится неактуальной

   Вакансия может стать неактуальной если работодатель снимет ее, но работодатели могут
   забывать это сделать, поэтому можно предусмотреть тайм-аут или даже некоторое кол-во
   голосов соискателей, которые дозвонились но им сказали, что вакансия уже неактуальна.

* Сущности
** Поисковые профили

   #+CAPTION: Данные поискового профиля
   #+NAME: profile_flds
     | field name   | field type | note                                      |
     |--------------+------------+-------------------------------------------|
     | id           | serial     | идентификатор                             |
     | user-id      | integer    | владелец и создатель                      |
     | name         | varchar    | название профиля                          |
     | search-query | varchar    | поисковый запрос                          |
     | ts-create    | bigint     | время создания                            |
     | ts-last      | bigint     | время когда был использован последний раз |

** Вакансии

   #+CAPTION: Данные вакансии
   #+NAME: vacancy_flds
     | field name        | field type           | note                                                        |
     |-------------------+----------------------+-------------------------------------------------------------|
     | id                | serial               | идентификатор                                               |
     | profile-id        | integer              | идентификатор поискового профиля                            |
     | name              | varchar              | название вакансии                                           |
     | rem-id            | integer              | идентификатор вакансии на удаленном ресурсе                 |
     | rem-date          | varchar              | дата создания вакансии на удаленном ресурсе                 |
     | rem-employer-name | varchar              | имя работодателя на удаленном ресурсе                       |
     | rem-employer-id   | (or db-null integer) | идентификатор работодателя на удаленном ресурсе             |
     | currency          | (or db-null varchar) | валюта зарплаты                                             |
     | salary            | (or db-null integer) | размер компенсации                                          |
     | salary-text       | (or db-null varchar) | размер компенсации                                          |
     | contact           | (or db-null varchar) | телефон контактного лица                                    |
     | text              | (or db-null varchar) | описание вакансии                                           |
     | history           | (or db-null varchar) | список изменения статусов со временем каждого изменения     |
     | reason            | (or db-null varchar) | добавляем причину действия (позже ссылка на другую таблицу) |
     | ts-created        | (or db-null bigint)  | время создания вакансии                                     |
     | ts-viewed         | (or db-null bigint)  | время когда вакансия была просмотрена                       |


   Вакансии могут появляться у нас следующими путями:
   - Работодатель может создать вакансию
   - Мы можем получить вакансию анализируя другой сайт

   В случае, если мы получаем вакансию анализируя другой сайт, мы получаем ее в 2 этапа. На
   первом этапе мы разобрали т.н. "тизер вакансии" и занесли ее в базу данных в состоянии
   =teaser=, чтобы потом получить все остальные данные. На втором этапе мы получаем данные
   со страницы вакансии и устанавливаем состояние =new=.

   Если пользователю не нравится тизер и он решает скрыть вакансию - она сразу из состояния
   =teaser= попадает в состояние =not_interested=.

   Если же пользователю наоборот, нравится вакансия, она из состояния =teaser= попадает в
   состояние =interested=.

   Когда вакансия переносится в архив - мы должны отслеживать это на стороннем сайте и
   реагировать, устанавливая статус =archive=

   TODO: Конечный автомат тут сложен и будет еще уточняться... Пока состояния такие:
    =просмотрено= (с датой), =отобрано=, =не-берут-трубку=, =не-актуально=,
    =приглашен-на-интервью=, =тестовое-задание=, =получен-оффер=, =отказано-работодателем=,
    =отказ-соискателя=, =вакансия-снята= итп.

   С точки зрения соискателя процесс найма выглядит так (неплохо бы приложить временную
   схему протокола):

   - Этап поиска
     - Поиск и просмотр вакансий, отсев, ранжирование
     - Рассылка откликов
   - Этап телефонных переговоров
     - Получение звонков, обсуждение деталей по телефону
     - Опционально: договоренность о еще одном звонке
     - Опционально: тестовое задание на почту
     - Опционально: договоренность о skype-интервью
   - Этап удаленного тестирования
     - Skype-интервью
     - Ожидание тестового задания
     - Выполнение тестового задания
   - Этап очного собеседования
     - Приглашение на интервью
     - Интервью
   - Этап отбора предложений
     - Получение предложений
     - Выбор предложения

   Когда мы собираем вакансии, распарсивая их с других сайтов, мы должны отслеживать их
   состояние на этих сайтах. Мы узнаем о вакансии, ко

   Вакансия создается в состоянии "новая" - =new=. После просмотра пользователем вакансия
   автоматически переходит в состояние "просмотрена" - =viewed=. Однако пользователь может
   перевести ее обратно в состояние =new= если ему так захотелось.

   Если пользователю вакансия не нравится он может выкинуть ее, чтобы больше к ней не
   возвращаться, после чего она становится =hidden=. Однако пользователь может передумать и
   тогда ему нужно предоставлять корзину выкинутых вакансий, чтобы он мог ее восстановить. В
   таком случае нам нужно помнить предыдущий статус выкинутой вакансии.

   Если вакансия пользователю понравилась - он может отправить отклик через форму (TODO:
   создать таблицу откликов, чтобы пользователь мог просто выбрать среди них, а не печатать
   одно и то же для каждой вакансии). После посылки отклика (если она прошла успешно)
   вакансия переходит в состяние "отклик послан" - =responded=.

   Если пользователь просмотрел вакансию, но пока не хочет отправлять отзыв - он может
   добавить вакансию в закладки - в этом случае ее статус меняется на =favorited=

   Из =favorited= мы снова можем отправить отзыв.

   Из =favorited= пользователь может вернуть вакансию обратно в =viewed= или выкинуть

   Если по вакансии позвонили, пользователю обычно нужно ее быстро найти. Нужна форма поиска
   по вакансиям в статусе =responded= - пользователь ищет обычно по названию фирмы.

   После звонка вакансия может быть выкинута или переведена из =responded= в статус "был
   телефонный звонок" - =called=. Выкидывая вакансию пользователь может выбрать reason - для
   них можно будет потом сделать отдельную таблицу но пока просто пишем в поле
   вакансии. Если в результате телефонного звонка была достигнута договоренность о
   собеседовании - пользователь переводит вакансию в состояние "пригласили на интервью" -
   =wait-interview= и заносит в вакансию данные о том, куда и во сколько ехать. Если по
   телефону рекрутер предложил тестовое задание - статус - "ожидание тестового задания" -
   =wait-test=. Если договорились о интервью по скайпу - "ожидание скайп-интервью" -
   =wait-skype-interview=.

   Получив тестовое задание пользователь переводит вакансию из статуса =wait-test= в
   "выполнение тестового задания" =run-test=, а оттуда либо в =test-cancel= либо в
   =test-sended=. Либо выкидывает.

   Пользователи иногда забивают на интервью (случаются накладки) - в этом случае рекрутер
   часто передоговаривается на другое время. Делать петли в графе значит излишне усложнять
   его, наверно пусть можно будет просто изменить данные о времени интервью.

   После интервью или скайп-интервью от вакансии можно либо отказаться (=refuse-employer=,
   =refuse-applicant=) либо перевести в статус "ожидание результата" - =wait-result=. Нужно
   включать таймер, по истечении которого напоминать пользователю позвонить рекрутеру и
   узнать, как дела.

   Иногда после скайп-интервью назначают очное интервью. Также бывает прямо на интервью
   предлагают оффер - =offer= и соискатель берет время на подумать.

   Из "ожидания результата" можно перескочить в "предложен оффер", "отказ работодателя" -
   =refuse-employer= или "отказ соискателя" - =refuse-аpplicant=.

   История статусов нужна, в нее нужно заносить время когда изменяется статус и возможно
   примечания по изменению. Будет красиво, если в интерфейсе будет отображаться полный граф
   статусов и текущее положение вакансии в нем.

   #+CAPTION: Состояния конечного автомата вакансии
   #+NAME: vacancy_state
     | action                                 | from                 | to                   |
     |----------------------------------------+----------------------+----------------------|
     | teaser-rejection                       | teaser               | not_interested       |
     | rejection-favorite                     | teaser               | interested           |
     | parsing                                | teaser               | new                  |
     | view                                   | new                  | viewed               |
     | renew                                  | viewed               | new                  |
     | hide-after-view                        | viewed               | hidden               |
     | restore-from-hidden-to-view            | hidden               | viewed               |
     | send-respond-from-view                 | viewed               | responded            |
     | favor                                  | viewed               | favorited            |
     | send-respond-from-favorited            | favorited            | responded            |
     | unfavor                                | favorited            | viewed               |
     | hide-after-favor                       | favorited            | hidden               |
     | call                                   | responded            | called               |
     | invite-interview                       | called               | wait_interview       |
     | invite-skype-interview                 | called               | wait_skype_interview |
     | invite-test                            | called               | wait_test            |
     | interview                              | wait_interview       | interview            |
     | skype-interview                        | wait_skype_interview | skype_interview      |
     | call-after-skype-interview             | skype_interview      | called               |
     | execute-test                           | wait_test            | run_test             |
     | send-test                              | run_test             | send_test            |
     | called-after-test                      | send_test            | called               |
     | refuse-employer-after-interview        | interview            | refuse_employer      |
     | refuse-applicant-after-interview       | interview            | refuse_applicant     |
     | wait-result-after-interview            | interview            | wait_result          |
     | refuse-employer-after-skype-interview  | skype_interview      | refuse_employer      |
     | refuse-applicant-after-skype-interview | skype_interview      | refuse_applicant     |
     | wait-result-after-skype-interview      | skype_interview      | wait_result          |
     | invite-next-interview                  | wait_result          | interview            |
     | invite-interview-after-skype           | skype_interview      | interview            |
     | invite-offer                           | wait_result          | offer                |
     | employer-refuse-after-wait-result      | wait_result          | refuse_employer      |
     | applicant-refuse-after-wait-result     | wait_result          | refuse_applicant     |

   Теперь мы можем полностью описать поведение вакансии как конечный автомат:

   #+NAME: vacancy_state_graph
   #+BEGIN_SRC emacs-lisp :var table=vacancy_state :results output :exports none
     (mapcar #'(lambda (x)
                 (princ (format "%s -> %s [label =\"%s\"];\n"
                                (second x) (third x) (first x))))
             table)
   #+END_SRC


   #+BEGIN_SRC dot :file img/vacancy-state.png :var input=vacancy_state_graph :exports results
     digraph G {
       rankdir = LR;
       $input
     }
   #+END_SRC


   #+NAME: hh_fn_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defun teaser-rejection ()
       "teaser-rejection")

     (defun rejection-favorite ()
       "rejection-favorite")
   #+END_SRC


** TODO Перекрестные связи с другими вакансиями

   В ряде случаев компании меняют свои вакансии, некоторые делают это методом удаления
   предыдущей и создания новой. Мне как соискателю хотелось бы не обнаруживать уже
   просмотренную и возможно собеседованную вакансию в новых. Поэтому хотелось бы
   предусмотреть механизм, который связывает очень похожие вакансии друг с другом.

   Иногда вакансии меняются, или в них меняются существенные условия. Например, две недели
   назад, когда я смотрел вакансию из предыдущей сборки меня не устроила зарпалата, а
   сегодня вакансия стала интереснее. Я хочу отслеживать что вакансия поменялась.

   Таким образом при создании вакансии мы должны проверять, может она уже есть в базе и
   тогда указывать, что эта вакансия включена в несколько сборок (требует таблицы связи)

** Компании

   Несколько вакансий могут быть от одной компании. В этом случае мне бы хотелось
   отслеживать это в профиле компании, кроме того интересна аналитика по этой компании за
   определенный период времени.

   С социальной точки зрения интересно получать отзывы о компании от ее работников, в том
   числе и уволенных.

** Действия по вакансии: звонки, скайп-интервью, собеседования

   В эту таблицу заносим что сделано по каждой вакансии, которая находится в разработке

** Теги вакансий

   Помогают ориентироваться, когда вакансий много.

* Interface

  Соберем веб-интерфейс:

  #+NAME: iface
  #+BEGIN_SRC lisp :tangle src/mod/hh/iface.lisp :noweb tangle :exports none :padline no :comments link
    ;;;; iface.lisp

    (in-package #:moto)

    ;; Страницы
    <<iface_contents>>
  #+END_SRC

** Главная страница модуля
   #+NAME: iface_contents
   #+BEGIN_SRC lisp

     (in-package #:moto)

     (restas:define-route hh-main ("/hh")
       (with-wrapper
           "<h1>Главная страница</h1>"
         ))
   #+END_SRC

** Список поисковых профилей

  #+NAME: iface_contents
  #+BEGIN_SRC lisp
    (in-package #:moto)

    (define-iface-add-del-entity all-profiles "/profiles"
      "Поисковые профили"
      "Новый профиль"
      "Когда соискатель пользуется профильным сайтом он использует
       поисковые запросы, на основании которых мы можем формировать,
       гм... назовем это =поисковыми профилями=. Поисковый профиль - это
       запрос пользователя, плюс набор связанных с ним вакансий"
       #'all-profile "profile"
      (name)
      (frm
       (tbl
        (list
         (row "Название" (fld "name"))
         (row "Запрос" (fld "search"))
         (row "" %new%))))
      (:new (act-btn "NEW" "" "Создать")
            (progn
              (make-profile :name (getf p :name)
                            :user-id 1
                            :search-query (getf p :search)
                            :ts-create (get-universal-time)
                            :ts-last (get-universal-time))
              "Профиль создан"))
      (:del (act-btn "DEL" (id i) "Удалить")
            (progn
              (del-profile (getf p :data)))))
  #+END_SRC

** Страничка поискового профиля

   На страничке поискового профиля мы выводим все собранные по этому поисковому профилю
   вакансии. Будем считать что нас не особо интересуют вакансии без указания зарплаты,
   поэтому мы их просто отфильтровываем. После фильтрации сортируем в направлении уменьшения
   зарплаты.

   #+NAME: iface_contents
   #+BEGIN_SRC lisp

     (in-package #:moto)

     (defun vacancy-table (raw)
       (let ((vacs (sort (remove-if #'(lambda (x)
                                        (equal 0 (salary x)))
                                    raw)
                         #'(lambda (a b)
                             (> (salary a) (salary b))))))
         (format nil "<h2>Вакансий: ~A</h2>~%~A" (length vacs)
                 (tbl
                  (with-collection (vac vacs)
                    (tr
                     (td
                      (state vac))
                     (td
                      (format nil "<div style=\"background-color:green\">~A</div>"
                              (input "radio" :name (format nil "R~A" (id vac)) :value "y"
                                     :other (if (string= ":INTERESTED" (state vac)) "checked=\"checked\"" ""))))
                     (td
                      (format nil "<div style=\"background-color:red\">~A</div>"
                              (input "radio" :name (format nil "R~A" (id vac)) :value "n"
                                     :other (if (string= ":NOT_INTERESTED" (state vac)) "checked=\"checked\"" ""))))
                     (td (format nil "<a href=\"/vacancy/~A\">~A</a>" (id vac) (name vac)))
                     (td (salary-text vac))
                     (td (currency vac))))
                  :border 1))))

     (define-page profile "/profile/:userid"
       (let* ((i (parse-integer userid))
              (page-id (parse-integer userid))
              (u (get-profile i))
              (vacs (sort (remove-if #'(lambda (x)
                                         (equal 0 (salary x)))
                                     (find-vacancy :profile-id page-id))
                          #'(lambda (a b)
                              (> (salary a) (salary b))))))
         (if (null u)
             "Нет такого профиля"
             (format nil "~{~A~}"
                     (list
                      "<script>
                              function test (param) {
                                 $.post(
                                    \"/profile/1\",
                                    {act: param},
                                    function(data) {
                                       $(\"#dvtest\").html(data);
                                    }
                                );
                              };
                       </script>"
                      (format nil "<h1>Страница поискового профиля ~A</h1>" (id u))
                      (format nil "<h2>Данные поискового профиля ~A</h2>" (name u))
                      (frm
                       (tbl
                        (with-element (u u)
                          (row "Имя профиля" (fld "name" (name u)))
                          (row "Запрос" (fld "search" (search-query u)))
                          (row (hid "profile_id" (id u)) %change%))
                        :border 1))
                      (tbl
                       (tr
                        (td %show-all%)
                        (td %show-interests%)
                        (td %show-not-interests%)
                        (td %show-other%)))
                      (frm %proceess-interests%)
                      (frm
                       (list
                        "<br /><br />"
                        %clarify%
                        "<div id=\"dvtest\">dvtest</div>"))))))
       (:change  (act-btn "CHANGE" "" "Изменить")
                 (id (upd-profile (get-profile (parse-integer userid))
                                  (list :name (getf p :name) :search-query (getf p :query)))))
       (:clarify (act-btn "CLARIFY" "" "Уточнить")
                 (loop :for key :in (cddddr p) :by #'cddr :collect
                    (let* ((val (getf p key))
                           (id  (parse-integer (subseq (symbol-name key) 1)))
                           (vac (get-vacancy id)))
                      (list id
                            (cond ((string= "y" val)
                                   (unless (string= ":INTERESTED" (state vac))
                                     (takt vac :interested)))
                                  ((string= "n" val)
                                   (unless (string= ":NOT_INTERESTED" (state vac))
                                     (takt vac :not_interested)))
                                  (t "err param"))))))
       (:show-all (format nil "<input type=\"button\" onclick=\"test('SHOW-ALL');\" value=\"все\">")
                  (error 'ajax :output (vacancy-table (find-vacancy :profile-id 1))))
       (:show-interests (format nil "<input type=\"button\" onclick=\"test('SHOW-INTERESTS');\" value=\"интересные\">")
                        (error 'ajax :output (vacancy-table (find-vacancy :state ":INTERESTED" :profile-id 1))))
       (:show-not-interests (format nil "<input type=\"button\" onclick=\"test('SHOW-NOT-INTERESTS');\" value=\"неинтересные\">")
                            (error 'ajax :output (vacancy-table (find-vacancy :state ":NOT_INTERESTED" :profile-id 1))))
       (:show-other (format nil "<input type=\"button\" onclick=\"test('SHOW-OTHER');\" value=\"остальные\">")
                    (error 'ajax :output (vacancy-table (remove-if #'(lambda (x)
                                                                       (or (string= ":NOT_INTERESTED" (state x) )
                                                                           (string= ":INTERESTED" (state x))))
                                                                   (find-vacancy :profile-id 1)))))
       (:proceess-interests (act-btn "PROCEESS-INTERESTS" "" "Собрать данные интересных вакансий")
                            "TODO"))
   #+END_SRC

** Дашборд
* Тесты

  #+NAME: hh_test
  #+BEGIN_SRC lisp :noweb tangle :exports none

    ;; Тестируем hh
    (defun hh-test ()
      <<hh_test_contents>>
      (dbg "passed: hh-test~%"))
    (hh-test)
  #+END_SRC

  #+NAME: hh_test_contents
  #+BEGIN_SRC lisp :noweb tangle :exports none

  #+END_SRC
* Точки входа

  Соберем шаблоны:

  #+NAME: hh_tpl
  #+BEGIN_SRC closure-template-html :tangle src/mod/hh/hh-tpl.htm :noweb tangle :exports none
    // -*- mode: closure-template-html; fill-column: 140 -*-
    {namespace hhtpl}

    <<hhtpl_contents>>
  #+END_SRC

  Скомпилируем шаблоны при подготовке модуля

  #+NAME: hh_prepare
  #+BEGIN_SRC lisp :tangle src/mod/hh/hh-prepare.lisp :noweb tangle :exports none
    (in-package #:moto)

    ;; Скомпилируем шаблон
    (closure-template:compile-template
     :common-lisp-backend
     (pathname
      (concatenate 'string *base-path* "mod/hh/hh-tpl.htm")))
  #+END_SRC

  Соберем контроллеры и все функции, которые контроллеры вызывают

  #+NAME: hh_fn
  #+BEGIN_SRC lisp :tangle src/mod/hh/hh.lisp :noweb tangle :exports none
    (in-package #:moto)

    <<hh_fn_contents>>

    <<hh_parse>>

    <<hh_test>>
  #+END_SRC

* Сборка
** Утилиты

   #+NAME: utility_file
   #+BEGIN_SRC lisp :tangle src/mod/hh/util.lisp :noweb tangle :exports code  :padline no :comments link
     (in-package #:moto)

     (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0")

     (defparameter *cookies*
       (list "portal_tid=1291969547067-10909"
             "__utma=189530924.115785001.1291969547.1297497611.1297512149.377"
             "__utmc=3521885"))

     (setf *drakma-default-external-format* :utf-8)

     (defun get-headers (referer)
       `(
         ("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
         ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
         ("Accept-Charset" . "utf-8")
         ("Referer" . ,referer)
         ;; ("Cookie" . ,(format nil "~{~a; ~}" *cookies*))
         ("Cookie" . "ad20c=2; ad17c=2; __utma=48706362.2093251633.1396569814.1413985658.1413990550.145; __utmz=48706362.1413926450.142.18.utmcsr=vk.com|utmccn=(referral)|utmcmd=referral|utmcct=/im; email=avenger-f%40yandex.ru; password=30e3465569cc7433b34d42baeadff18f; PHPSESSID=ms1rrsgjqvm3lhdl5af1aekvv0; __utmc=48706362; __utmb=48706362.5.10.1413990550")
         ))

     (defmacro web (to ot)
       (let ((x-to (append '(format nil) to))
             (x-ot (append '(format nil) ot)))
         `(let ((r (sb-ext:octets-to-string
                    (drakma:http-request ,x-to
                                         :user-agent *user-agent*
                                         :additional-headers (get-headers ,x-ot)
                                         :force-binary t)
                    :external-format :utf-8)))
            r)))

     (defmacro fnd (var pattern)
       `(multiple-value-bind (all matches)
            (ppcre:scan-to-strings ,pattern ,var)
          (let ((str (format nil "~a" matches)))
            (subseq str 2 (- (length str) 1)))))
   #+END_SRC

** Глобальные определения

   #+NAME: globals
   #+BEGIN_SRC lisp :tangle src/mod/hh/globals.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:moto)

     ;; clear db
     (drop '("profile" "vacancy"))
   #+END_SRC

** Сущности и автоматы

   Соберем все сущности и автоматы

   #+NAME: entity_and_automates
   #+BEGIN_SRC lisp :tangle src/mod/hh/entityes.lisp :noweb tangle :exports none :padline no :comments link
     (in-package #:moto)

     <<asm_profile()>>

     <<asm_vacancy()>>
   #+END_SRC

** Поисковые профили

    #+NAME: asm_profile
    #+BEGIN_SRC emacs-lisp :var flds=profile_flds :exports none
      (gen-entity "profile" "поисковые профили" flds)
    #+END_SRC

** Вакансии

    #+NAME: asm_vacancy
    #+BEGIN_SRC emacs-lisp :var flds=vacancy_flds states=vacancy_state :exports none
      (gen-automat "vacancy" "вакансии" flds states)
    #+END_SRC
