#+HTML_HEAD: -*- fill-column: 92 -*-

#+TITLE: Модуль HeadHunter

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

* Цель

  Мы все ищем работу на профильных сайтах время от времени. Иногда на это уходит
  значительное время, т.к. мы выполняем множество рутинных действий, которых могли бы
  избежать. Попробуем автоматизировать этот процесс.

* Суть

  Пусть у нас есть источник вакансий, например, hh.ru

  Пусть у нас есть =генератор функций=, назовем его =metagen=, который принимает источник
  вакансий и параметры запроса (например: профессиональную область, специализацию, город) и
  возвращает функцию, которая при каждом своем вызове вернет одну вакансию или =ложь= если
  вакансии кончились.

  #+NAME: metagen
  #+BEGIN_SRC lisp
    (in-package #:moto)

    (defun metagen (vac-src city prof-area &optional spec)
      (ecase vac-src
        (hh (let ((url     (make-hh-url 'hh city prof-area spec))
                  (page    0)
                  (teasers nil))
              (alexandria:named-lambda get-vacancy ()
                (labels ((next-vac ()
                               (let* ((current-teaser  (car teasers))
                                      (current-vacancy (hh-parse-vacancy (hh-get-page (getf current-teaser :id))))
                                      (result (merge-plists current-teaser current-vacancy)))
                                 (setf teasers (cdr teasers))
                                 result)))
                  (if (null teasers)
                      (progn
                        (setf teasers (hh-parse-vacancy-teasers (hh-get-page (format nil url page))))
                        (if (null teasers)
                            (return-from get-vacancy 'nil)
                          (next-vac)))
                      (next-vac))))))))
  #+END_SRC

  Для работы этому генератору нужно уметь:
  - Собирать URL страницы, где лежат тизеры (краткие описания) вакансий (=make-hh-url=)
  - Скачивать HTML-страницы (=hh-get-page=)
  - Разбирать тизеры (=hh-parse-vacancy-teasers=)
  - Разбирать вакансии (=hh-parse-vacancy=)
  Но мы не будем сейчас на всем этом останавливаться и опишем это потом, в соотвествующих разделах

  Пусть у нас есть возможность создавать =правила=, которые получают на вход вакансию,
  анализируют ее, и выполняют некие действия. Например, мы могли бы создать правило, которое
  добавляет к вакансии поле =interested= если зарплата и язык разработки нас устраивает.

  Примем соглашение, что правило возвращает =ложь= если вакансия нам не интересна.

  #+NAME: define-rule
  #+BEGIN_SRC lisp
    (in-package #:moto)

    (defmacro define-rule (name condition &body body)
      `(alexandria:named-lambda ,name (vacancy)
         (if ,condition
             ,@body)
         vacancy))

    ;; expand

    ;; (macroexpand-1 ' (define-rule test-rule
    ;;                      (or
    ;;                       (< (getf vacancy :salary) 50000)
    ;;                       (contains (getf vacancy :name) "Java"))
    ;;                    (return-from test-rule nil)))

    ;; => (ALEXANDRIA.0.DEV:NAMED-LAMBDA TEST-RULE
    ;;        (VACANCY)
    ;;      (IF (OR (< (GETF VACANCY :SALARY) 50000)
    ;;              (CONTAINS (GETF VACANCY :NAME) "Java"))
    ;;          (RETURN-FROM TEST-RULE NIL))
    ;;      VACANCY), T

    ;; test

    ;; (funcall
    ;;  (define-rule test-rule
    ;;    (and
    ;;       (> (getf vacancy :salary) 70000)
    ;;       (not (contains "Java" (getf vacancy :name))))
    ;;    (setf (getf vacancy :interested) t))
    ;;  '(:name "Python" :salary 80000)

    ;; => (:INTERESTED T :NAME "Python" :SALARY 80000)

    ;; (funcall
    ;;  (define-rule test-rule
    ;;      (or
    ;;       (< (getf vacancy :salary) 50000)
    ;;       (contains (getf vacancy :name) "Java"))
    ;;    (return-from test-rule nil))
    ;;  '(:name "Java Developer" :salary 120000))

    ;; => NIL
  #+END_SRC

  Теперь мы можем создать комбинатор правил =process-vacancy=, который последовательно
  применяет переданный ему набор правил к вакансии. Если одно из правил возвратило =ложь= -
  остальные правила не применяются и возвращается =ложь=.

  #+NAME: combinator
  #+BEGIN_SRC lisp
    (in-package #:moto)

    (defmacro maybe-rules (vacancy &rest rules)
      `(maybecall
        ,vacancy
        ,@(loop :for (name condition action) :in rules :collect
             `(define-rule ,name ,condition ,action))))

    (print
     (macroexpand-1 '(maybe-rules '(:name "Android Developer" :salary 90000)
                      (test-rule
                       (or
                        (< (getf vacancy :salary) 50000)
                        (contains (getf vacancy :name) "Java"))
                       (return-from test-rule nil))
                      (test-rule
                       (or
                        (< (getf vacancy :salary) 50000)
                        (contains (getf vacancy :name) "Android"))
                       (setf (getf vacancy :stack) "mobile")))))

    (defun process-vacancy (vacancy)
      (maybe-rules
       vacancy
       (drop-java-low-price (or
                             (< (getf vacancy :salary) 50000)
                             (contains (getf vacancy :name) "Java"))
                            (return-from test-rule nil))
       (stack-mobile
        (or
         (< (getf vacancy :salary) 50000)
         (contains (getf vacancy :name) "Android"))
        (setf (getf vacancy :stack) "mobile"))))

    (process-vacancy '(:name "Android Developer" :salary 80000))
  #+END_SRC

  Теперь мы можем построить бесконечный цикл, которому Гена дает вакансии, а он применяет
  правила и выполняет действия (продукционная система)

  Какие же правила и действия можно составить? А какие мы захотим:

  - Я не хочу даже смотреть на вакансии, в которых нет указания з/п
  - Если это уже существующая в базе вакансия и ничего не изменилось - игнорируем, иначе
    заносим в базу.
  - Я не хочу смотреть на вакансии, у которых в названии вакансии есть слово Java
  - Я не хочу смотреть на вакансии, в компаниях где я уже работал.
  - Я хочу присвоить вакансии определенный ранг, в зависимости от з\п
  - Я хочу увеличивать этот ранг за упоминание в тексте описания вакансии слов Lisp, Erlang
  - Я хочу [отправить отклик] на вакансии, у которых ранг выше [порогового ранга]

  Отправка отклика, заметьте, происходит автоматически. После этого мне внезапно звонит
  работодатель и приглашает на интервью.

  В этот момент я хочу [найти вакансию], глянуть ее и в зависимости от того до чего мы
  договорились с работодателем выставить ей некоторое состояние.

  Я также хочу чтобы система проходила по вакансиям и в зависимости от сочетания условий
  выполняла какие-то действия

  - напоминание мне о собеседованиях, звонках (календарь)
  - автоматическое ранжирование вакансий (по перспективам найма, зарплате и.т.п)





  #+NAME: metagen
  #+BEGIN_SRC lisp
    (defparameter *tmp*
      (meta-gen 'hh "spb" "Информационные технологии, интернет, телеком" "Программирование, Разработка"))

    (print (funcall *tmp*))


    (defparameter *prof-areas*
      '(("Все профессиональные области" . (""))
        ("Информационные технологии, интернет, телеком"
         . ("1" (("CRM системы" . "536")
                 ("CTO, CIO, Директор по IT" . "3")
                 ("Web инженер" . "9")
                 ("Web мастер" . "10")
                 ("Администратор баз данных" . "420")
                 ("Аналитик" . "25")
                 ("Арт-директор" . "30")
                 ("Банковское ПО" . "395")
                 ("Игровое ПО" . "475")
                 ("Инженер" . "82")
                 ("Интернет" . "89")
                 ("Компьютерная безопасность" . "110")
                 ("Консалтинг, Аутсорсинг" . "113")
                 ("Контент" . "116")
                 ("Маркетинг" . "137")
                 ("Мультимедиа" . "161")
                 ("Начальный уровень, Мало опыта" . "172")
                 ("Оптимизация сайта (SEO)" . "400")
                 ("Передача данных и доступ в интернет" . "203")
                 ("Поддержка, Helpdesk" . "211")
                 ("Программирование, Разработка" . "221")
                 ("Продажи" . "225")
                 ("Продюсер" . "232")
                 ("Развитие бизнеса" . "246")
                 ("Сетевые технологии" . "270")
                 ("Системная интеграция" . "272")
                 ("Системный администратор" . "273")
                 ("Системы автоматизированного проектирования" . "274")
                 ("Системы управления предприятием (ERP)" . "50")
                 ("Сотовые, Беспроводные технологии" . "277")
                 ("Стартапы" . "474")
                 ("Телекоммуникации" . "295")
                 ("Тестирование" . "117")
                 ("Технический писатель" . "296")
                 ("Управление проектами" . "327")
                 ("Электронная коммерция" . "359"))))
        ("Бухгалтерия, управленческий учет, финансы предприятия" . ("2"))
        ("Маркетинг, реклама, PR" . ("3"))
        ("Административный персонал" . ("4"))
        ("Банки, инвестиции, лизинг" . ("5"))
        ("Управление персоналом, тренинги" . ("6"))
        ("Автомобильный бизнес" . ("7"))
        ("Безопасность" . ("8"))
        ("Высший менеджмент" . ("9"))
        ("Добыча сырья" . ("10"))
        ("Искусство, развлечения, масс-медиа" . ("11"))
        ("Консультирование" . ("12"))
        ("Медицина, фармацевтика" . ("13"))
        ("Наука, образование" . ("14"))
        ("Государственная служба, некоммерческие организации" . ("16"))
        ("Продажи" . ("17"))
        ("Производство" . ("18"))
        ("Страхование" . ("19"))
        ("Строительство, недвижимость" . ("20"))
        ("Транспорт, логистика" . ("21"))
        ("Туризм, гостиницы, рестораны" . ("22"))
        ("Юристы" . ("23"))
        ("Спортивные клубы, фитнес, салоны красоты" . ("24"))
        ("Инсталляция и сервис" . ("25"))
        ("Закупки" . ("26"))
        ("Начало карьеры, студенты" . ("15"))
        ("Домашний персонал" . ("27"))
        ("Рабочий персонал" . ("29"))))


    (defun make-specialization-hh-url-string (prof-area &optional specs)
      (let ((specialization (assoc prof-area *prof-areas* :test #'equal)))
        (when (null specialization)
          (err 'specialization-not-found))
        (when (stringp specs)
          (setf specs (list specs)))
        (if (null specs)
            (concatenate 'string
                         "&specialization="
                         (cadr specialization))
            (format nil "~{&~A~}"
                    (loop :for spec :in specs :collect
                       (let ((spec (cdr (assoc spec (caddr specialization) :test #'equal))))
                         (when (null spec)
                           (err 'spec-not-found))
                         (concatenate 'string "specialization=" (cadr specialization) "." spec)))))))

    (make-specialization-hh-url-string "Информационные технологии, интернет, телеком")
    (make-specialization-hh-url-string "Информационные технологии, интернет, телеком" '("Программирование, Разработка"))
    (make-specialization-hh-url-string "Информационные технологии, интернет, телеком" "Программирование, Разработка")
    (make-specialization-hh-url-string "Информационные технологии, интернет, телеком"
                                    '("Программирование, Разработка"
                                      "Web инженер"
                                      "Web мастер"
                                      "Инженер"
                                      "Системы управления предприятием (ERP)"
                                      "Сотовые, Беспроводные технологии"
                                      "Стартапы"
                                      "Телекоммуникации"
                                      "Управление проектами"
                                      "Электронная коммерция"))

    (defun make-hh-url (vac-src city prof-area &optional specs)
      (format nil "http://~A.hh.ru/search/vacancy?clusters=true&specialization=~A&area=~A&page=~~A"
              city
              (make-specialization-hh-url-string prof-area specs)
              2))

    (make-hh-url 'hh "spb" "Информационные технологии, интернет, телеком" "Программирование, Разработка")



      (defparameter *programmin-and-development-profile*
        (make-profile :name "Программирование и разработка"
                      :user-id 1
                      :search-query
                      :ts-create (get-universal-time)
                      :ts-last (get-universal-time)))

      (defun run-collect (profile)
        (let* ((search-str   (search-query profile))
               (all-teasers  nil))
          (block get-all-hh-teasers
            (loop :for num :from 0 :to 100 :do
               (print num)
               (let* ((url (format nil search-str num))
                      (teasers (hh-parse-vacancy-teasers (hh-get-page url))))
                 (if (equal 0 (length teasers))
                     (return-from get-all-hh-teasers)
                     (setf all-teasers (append all-teasers teasers)))))
            (print "over-100"))
          all-teasers))
  #+END_SRC

* Хотелки

  Мы все ищем работу на профильных сайтах, но, к сожалению, не всегда на них хватает
  функционала, особенно нестандартного. Работая с сайтом в автоматическом режиме мы можем
  восполнить этот пробел.

  Кроме того есть множество конкурирующих сайтов для поиска работы, информацию с которых
  можно аггрегировать.

  При поиске работы основной сценарий использования - =поиск вакансий=, и практически все
  сайты его предоставляют. Однако мне бы хотелось дополнительно иметь дополнительный
  функционал:

  - заметки по каждой вакансии
  - статусы или теги, такие как:
    - =просмотрено= (с датой),
    - =отобрано=,
    - =не-берут-трубку=,
    - =не-актуально=,
    - =приглашен-на-интервью=,
    - =выслали-тестовое-задание=,
    - =отправил-тестовое-задание=,
    - =получен-оффер=,
    - =вакансия-закрыта= итп.

  Я бы хотел ранжировать вакансии вручную (по выставленным приоритетам) и автоматически
  (т.е. скриптом), например в зависимости от зарплаты или удаленности.

  Я бы хотел иметь возможность планировать маршрут, когда еду на собеседование и иметь
  календарь, чтобы не пропустить встречу.

  Я бы хотел иметь версии вакансий, чтобы отслеживать их изменения, например изменения
  зарплаты до и после моего интервью - это позволит анализировать рынок и получать больше
  информации.

  Мне также интересно составлять профили компаний и отслеживать как меняется набор
  сотрудников которых они ищут - это поможет планировать долгосрочную стратегию. Особенно в
  этом плане интересны лидеры рынка - Яндекс, Гугл и.т.п.

  Я бы хотел иметь возможность пообщаться с теми кто работал или работает в интересующей
  меня компании, иметь подмножество функционала социальных сетей или интеграцию с ними

  Иногда мне приятно работать с уже знакомыми людьми, так что в целом я бы не отказался
  создавать на таком сайте что-то типа т.н. =рабочих коллективов=, чтобы наниматься сразу
  командой. Возможно работодателям такой вариант найма тоже будет интересен.

** Процесс найма с т.з. соискателя

   С точки зрения соискателя процесс найма выглядит так:

   - Этап составления резюме
   - Этап опубликования резюме
   - Этап поиска
     - Поиск и просмотр вакансий, отсев, ранжирование
     - Рассылка откликов
   - Этап телефонных переговоров
     - Получение звонков, обсуждение деталей по телефону
     - Договоренность о еще одном звонке
     - Тестовое задание на почту
     - Договоренность о skype-интервью
   - Этап удаленного тестирования
     - Skype-интервью
     - Ожидание тестового задания
     - Выполнение тестового задания
   - Этап очного собеседования
     - Приглашение на интервью
     - Интервью
   - Этап отбора предложений
     - Получение предложений
     - Выбор предложения

** Процесс найма с т.з. HR-а

   Когда HR-специалист ищет вакансии, он пользуется несколькими путями:
   - Личные знакомства
   - Рекомендации
   - Социальные сети
     - LinkedIn
     - vkontakte
   - Помощь коллег
   - Специализированные сайты

   Как правило, HR-специалист менее компетентен в предметной области, чем нанимаемый
   сотрудник, поэтому для него имеет большой вес мнение рекомендателей и коллег
   соискателя. Вероятно, рекомендательный сервис был бы очень актуален.

   Компании-работодатели выбирают одну из моделей найма, в соответствии со своим бюджетом и
   задачами:
   - Всегда (на любую позицию) нанимать (переманивать) лучших
   - Нанимать начинающих в подчинение лучшим
   - Нанимать начинающих (конвеерная разработка, большая текучка)
   - Нанимать тех, кто понравится лидеру отдела
   - Нанимать тех, кто лучше соответствует корпоративной культуре

   Для каждой из этих моделей характерны свои необходимые сервисы. К примеру, для модели
   "нанимать лучших" совершенно необходимо вести и актуализировать базу этих "лучших", чтобы
   вовремя сделать предложение кандидату. О примерах внедрения таких сервисов мне ничего не
   известно. Также интересно уточнить у HR-специалистов из =разных= компаний их методы
   работы.

   Для HR-специалиста процесс найма выгядит (в общих чертах) так.

   - Этап составления вакансий
   - Этап опубликования вакансий
   - Этап поиска резюме
     - По ключевым словам
     - По фильтру
     - Используя автоподбор
   - Этап анализа откликов (неразобранные, подумать, приглашенные, отклоненные)
   - Телефонный звонок соискателю (с целью уточнить детали или пригласить)
   - Возможно отправка тестового задания
   - Получение тестового задания
   - Проверка тестового задания
   - Скайп-интервью
   - Этап собеседования
     - Опциоанльно: заполнение анкеты
     - Собеседование с HR-специалистом (об условиях)
     - Тесты (например: на знание языка, ООП, БД, многопоточность)
     - Тестовое задание
     - Проверка тестового задания
     - Собеседование с тех. спецом, (как правило нач. отдела)

   HR-специалист анализирует обратную связь о составляемых им вакансиях - у него есть
   статистическая информация о кол-ве просмотров вакансий и количестве поступивших
   откликов. Из этих данных можно, например, сделать вывод, что предложенная зарплата
   неактуальна на рынке.

   Также HR-специалист заинтересован в технической поддержке при решении задач типа:
   - Мониторинг резюме (сообщения о обновлении резюме, просмотр старой версии)
   - Ведение базы кандидатов (часто в экселе)

   HR-специалист заинтересован в том, чтобы иметь возможность построить процесс найма под
   себя.

** Состояния вакансий

   После того, как тизер вакансии будет загружен системой, вакансия получает статус =new= и
   помечается в интерфейсе специальным значком, чтобы обратить на себя внимание
   пользователя. В дальнейшем эти тизеры попадают на автоматическую и ручную сортировку и
   могут принять один из статусов: =unsorted=, =interested= или =not-interested=

   После того, как пользователь определился с интересными ему тизерами, он иницирует
   загрузку полной информции о вакансиях и они становятся доступны для просмотра и внесения
   заметок.

   Пользователь, работая с этими интересными вакансиями, отслеживает их состояния, выполняя
   действия, переводящие вакансию из одного состояния в другое: когда пользователь
   отправляет отзыв  вакансия становится =responded=. Если пользователь, просмотрев
   вакансию, принял решение отзыв не отправлять, он может сделать вакансию =hidden=.

   Важно: Для обеспечения социальных взаимодействий нужно предусмотреть, чтобы вакансию
   можно было "передать", т.е. у нее минимум должен быть URI.

   Если пользователь просмотрел вакансию, но пока не хочет отправлять отзыв - он может
   добавить вакансию в закладки - в этом случае ее статус меняется на =favorited=

   Из =favorited= мы снова можем отправить отзыв.

   Из =favorited= пользователь может вернуть вакансию обратно в =interested= или =hidden=.

   Из =hidden= пользователь может вернуть вакансию в =interested=.

   Если по вакансии позвонили, пользователю обычно нужно ее быстро найти. Нужна форма поиска
   по вакансиям в статусе =responded= - пользователь ищет обычно по названию фирмы.

   После звонка вакансия может быть выкинута или переведена из =responded= в статус "был
   телефонный звонок" - =called=. Выкидывая вакансию пользователь может выбрать reason - для
   них можно будет потом сделать отдельную таблицу но пока просто пишем в поле
   вакансии. Если в результате телефонного звонка была достигнута договоренность о
   собеседовании - пользователь переводит вакансию в состояние "пригласили на интервью" -
   =wait-interview= и заносит в вакансию данные о том, куда и во сколько ехать. Если по
   телефону рекрутер предложил тестовое задание - статус - "ожидание тестового задания" -
   =wait-test=. Если договорились о интервью по скайпу - "ожидание скайп-интервью" -
   =wait-skype-interview=.

   Получив тестовое задание пользователь переводит вакансию из статуса =wait-test= в
   "выполнение тестового задания" =run-test=, а оттуда либо в =test-cancel= либо в
   =test-sended=. Либо выкидывает.

   Пользователи иногда забивают на интервью (случаются накладки) - в этом случае рекрутер
   часто передоговаривается на другое время. Делать петли в графе значит излишне усложнять
   его, наверно пусть можно будет просто изменить данные о времени интервью.

   После интервью или скайп-интервью от вакансии можно либо отказаться (=refuse-employer=,
   =refuse-applicant=) либо перевести в статус "ожидание результата" - =wait-result=. Нужно
   включать таймер, по истечении которого напоминать пользователю позвонить рекрутеру и
   узнать, как дела.

   Иногда после скайп-интервью назначают очное интервью. Также бывает прямо на интервью
   предлагают оффер - =offer= и соискатель берет время на подумать.

   Из "ожидания результата" можно перескочить в "предложен оффер", "отказ работодателя" -
   =refuse-employer= или "отказ соискателя" - =refuse-аpplicant=.

   История статусов нужна, в нее нужно заносить время когда изменяется статус и возможно
   примечания по изменению. Будет красиво, если в интерфейсе будет отображаться полный граф
   статусов и текущее положение вакансии в нем.

   #+CAPTION: Состояния конечного автомата вакансии
   #+NAME: vacancy_state
     | action                                 | from                 | to                   |
     |----------------------------------------+----------------------+----------------------|
     | view                                   | new                  | unsorted             |
     | refuse-new                             | new                  | not-interested       |
     | set-interested                         | new                  | interested           |
     | refuse-interested                      | interested           | hidden               |
     | respond                                | interested           | responded            |
     | favor                                  | interested           | favorited            |
     | send-respond-from-favorited            | favorited            | responded            |
     | unfavor                                | favorited            | interested           |
     | hide-after-favor                       | favorited            | hidden               |
     | call                                   | responded            | called               |
     | invite-interview                       | called               | wait_interview       |
     | invite-skype-interview                 | called               | wait_skype_interview |
     | invite-test                            | called               | wait_test            |
     | interview                              | wait_interview       | interview            |
     | skype-interview                        | wait_skype_interview | skype_interview      |
     | call-after-skype-interview             | skype_interview      | called               |
     | execute-test                           | wait_test            | run_test             |
     | send-test                              | run_test             | send_test            |
     | called-after-test                      | send_test            | called               |
     | refuse-employer-after-interview        | interview            | refuse_employer      |
     | refuse-applicant-after-interview       | interview            | refuse_applicant     |
     | wait-result-after-interview            | interview            | wait_result          |
     | refuse-employer-after-skype-interview  | skype_interview      | refuse_employer      |
     | refuse-applicant-after-skype-interview | skype_interview      | refuse_applicant     |
     | wait-result-after-skype-interview      | skype_interview      | wait_result          |
     | invite-next-interview                  | wait_result          | interview            |
     | invite-interview-after-skype           | skype_interview      | interview            |
     | invite-offer                           | wait_result          | offer                |
     | employer-refuse-after-wait-result      | wait_result          | refuse_employer      |
     | applicant-refuse-after-wait-result     | wait_result          | refuse_applicant     |

   Теперь мы можем полностью описать поведение вакансии как конечный автомат:

   #+NAME: vacancy_state_graph
   #+BEGIN_SRC emacs-lisp :var table=vacancy_state :results output :exports none
     (mapcar #'(lambda (x)
                 (princ (format "%s -> %s [label =\"%s\"];\n"
                                (second x) (third x) (first x))))
             table)
   #+END_SRC


   #+BEGIN_SRC dot :file img/vacancy-state.png :var input=vacancy_state_graph :exports results
     digraph G {
       rankdir = LR;
       $input
     }
   #+END_SRC


   #+NAME: hh_fn_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defun teaser-rejection ()
       "teaser-rejection")

     (defun rejection-favorite ()
       "rejection-favorite")
   #+END_SRC

* Сценарии использования
** Системные
*** Парсинг и сохранение данных

**** Сбор вакансий

     Система, ориентируясь на предпочтения пользователей собирает, разбирает в собственное
     представление, и сохраняет к себе в базу данных вакансии из различных источников

     Тизеры вакансий размещаются постранично, по 20 штук на странице, и мы можем собрать все
     страницы, если будем получать страницу за страницей, пока не получим страницу, на
     которой вакансий нет. Для того чтобы это реализовать нам нужно уметь получить страницу
     (=hh-get-page(url)=) и разобрать тизеры вакансий (=hh-parse-vacancy-teasers(html)=).

***** Получение страниц

    Вот так мы можем получать страницы, на который находятся тизеры:

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun hh-get-page (url)
        "Получение страницы"
        (flexi-streams:octets-to-string
         (drakma:http-request url
                              :user-agent "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:34.0) Gecko/20100101 Firefox/34.0"
                              :additional-headers `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
                                                    ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
                                                    ("Accept-Charset" . "utf-8")
                                                    ("Referer" . "http://spb.hh.ru/")
                                                    ("Cookie" . "redirect_host=spb.hh.ru; regions=2; __utma=192485224.1206865564.1390484616.1410378170.1417257232.29; __utmz=192485224.1390484616.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _xsrf=85014f262b894a1e9fc57b4b838e48e8; hhtoken=ES030IVQP52ULPbRqN9DQOcMIR!T; hhuid=x_FxSYWUbySJe1LhHIQxDA--; hhrole=anonymous; GMT=3; display=desktop; unique_banner_user=1418008672.846376826735616")
                                                    ("Cache-Control" . "max-age=0"))
                              :force-binary t)
         :external-format :utf-8))
    #+END_SRC

***** Обход дерева и извлечение узлов

    Чтобы эффективнее (с точки зрения скорости написания кода) разбирать вакансии) мы
    разберем всю полученную страницу в дерево, из которого будем извлекать необходимые нам
    элементы.

    Чтобы делать это будем обходить дерево, сопоставляя каждый узел с предикатом, в который
    скомпилируется образец. Начнем с обхода дерева, для этого напишем рекурсивную функцию
    =match-tree=, которую определим с помощью =labels=, чтобы иметь окружить ее формой =let=
    с аккумулятором.

    Определим параметры этой функции:
    - =tree= - под-дерево, которое мы рекурсивно обходим и должны для этого передавать
    - =predict= - функция-предикат, которая может совпасть с обходимым поддеревом
    - =if-match= - параметр чтобы иметь возможность передавать стратегию

    #+NAME: cond_tree
    #+BEGIN_SRC lisp
      (labels ((match-tree (tree f-predict &optional (if-match :return-first-match))
               (cond ((null tree) nil)
                     ((atom tree) nil)
                     (t
                      <<cons>>))))
        <<call>>)
    #+END_SRC

    Теперь переходим к рассмотрению плейсхолдера =cons=, который выполняет основную
    работу. В первую очередь нам следует сравнить текущий узел с параметром =predict= и в
    случае если =predict= вернул T - выполнить какие-то действия. В противном случае -
    обрабатываем поддеревья этого узла.

    #+NAME: cons
    #+BEGIN_SRC lisp
      (if (funcall f-predict tree)
          <<match_ok>>
          <<sub_trees>>)
    #+END_SRC

    #+NAME: sub_trees
    #+BEGIN_SRC lisp
      (cons
       (funcall #'match-tree (car tree) f-predict if-match)
       (funcall #'match-tree (cdr tree) f-predict if-match))
    #+END_SRC

    В случае, когда узел совпал с =predict= мы можем реализовать следующие стратегии:
    - Немедленно вернуть совпавший узел и более не обрабатывать никакие узлы.
    - Прекратить обработку всех подузлов сопавшего узла, запомнить его и перейти к обработке
      следующего за ним.
    - Запомнить совпавший узел и продолжить обработку вглубь совпавшего узла, а затем и всех
      остальных узлов.
    - Наиболее общий вариант - применить к сопавшему узлу переданную лямбда-функцию, которая
      может с ним что-то сделать - например записать в какую-нибудь переменную на более
      высоком уровне.
    Реализуем эти стратегии друг за другом.

    Реализуем выбор стратегии в общих чертах - будем использовать =cond= по параметру
    =if-match=. В случае, если в этом параметре не лежит keyword symbol с именем стратегии -
    считаем, что там функция, если это не так - сигнализируем ошибку
    =strategy-not-implemented= (которая пока нигде не определена - я считаю что ее имя
    говорит само за себя).

    #+NAME: match_ok
    #+BEGIN_SRC lisp
      (cond ((equal if-match :return-first-match)
             <<return-first-match>>)
            ((equal if-match :return-first-level-match)
             <<return-first-level-match>>)
            ((equal if-match :return-all-match)
             <<return-all-match>>)
            ((equal 'function (type-of if-match))
             (funcall if-match tree))
            (t (error 'strategy-not-implemented)))
    #+END_SRC

    Теперь приступим к реализации (первой) стратегии: немедленного возврата совпавшего
    узла. Для этого нам понадобится определить внешнюю функцию =tree-match=, чтобы
    возвращаться из нее, а не из текущего рекурсивного вызова =match-tree=. Мы сделаем это
    несколько позже, а пока заполним плейсхолдер =return-first-match=:

    #+NAME: return-first-match
    #+BEGIN_SRC lisp
      (return-from tree-match tree)
    #+END_SRC

    Теперь переходим ко второй стратегии - прекратить обработку всех подузлов сопавшего
    узла, запомнить его и перейти к обработке следующего за ним. Нам понадобиться переменная
    =collect= чтобы хранить значения, запомним это и реализуем добавление узла в нее. После
    того, как узел сохранен, мы не проводим обработку его под-деревьев, а переходим в
    следующему узлу этого уровня.

    #+NAME: return-first-level-match
    #+BEGIN_SRC lisp
      (setf collect
            (append collect (list tree)))
    #+END_SRC

    И наконец, реализуем последнюю оставшуюся стратегию, которая представляет из себя
    расширение предыдущей, но с обработкой вложенных узлов. Так и запишем:

    #+NAME: return-all-match
    #+BEGIN_SRC lisp
      (progn
        <<return-first-level-match>>
        <<sub_trees>>)
    #+END_SRC

    Теперь нам осталось лишь правильно возвращать результат. Если используются
    аккумулирующие стратегии, то мы возвращаем содержимое переменной =collect=, в случае
    немедленного возврата совпавшего узла мы никогда не окажемся в этом месте, а в случае
    передачи в =if-match= лямбда-фукции - мы будем считать, что она как-нибудь сама
    заботится о передачи значений. Поэтому всегда будем возвращать =collect=.

    #+NAME: call
    #+BEGIN_SRC lisp
      (match-tree tree predict if-match)
      collect
    #+END_SRC

    Осталось обернуть это все во внешнюю функцию, с аккумулятором:

    #+NAME: tree-match
    #+BEGIN_SRC lisp
      (defun tree-match (tree predict &optional (if-match :return-first-match))
        (let ((collect))
          <<cond_tree>>))
    #+END_SRC

    И теперь мы можем поместить все это в выходной файл

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      <<tree-match>>
    #+END_SRC

    Но для удобной работы этого недостаточно, поэтому напишем компилер шаблона в
    соответствующий ему =predict=. Этот компилер будет принимать в качестве параметра форму,
    которая будет связываться с элементами шаблона с помощью =destructuring-bind=. Попытка
    связывания будет проводиться для каждого элемента дерева, ошибки, которые возникают в
    случае невозможности связывания, игнорируются.

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defmacro with-predict (pattern &body body)
        (let ((lambda-param (gensym)))
          `#'(lambda (,lambda-param)
               (handler-case
                   (destructuring-bind ,pattern
                       ,lambda-param
                     ,@body)
                 (sb-kernel::arg-count-error nil)
                 (sb-kernel::defmacro-bogus-sublist-error nil)))))

      ;; (macroexpand-1 '
      ;;  (with-predict (a ((b c)) d &rest e)
      ;;    (aif (and (string= a "div")
      ;;              (string= c "title b-vacancy-title"))
      ;;         (prog1 it
      ;;           (setf **a** a)
      ;;           (setf **b** b)))))

      ;; => #'(LAMBDA (LAMBDA-PARAM)
      ;;        (HANDLER-CASE
      ;;            (DESTRUCTURING-BIND
      ;;                  (A ((B C)) D &REST E)
      ;;                LAMBDA-PARAM
      ;;              (AIF (AND (STRING= A "div") (STRING= C "title b-vacancy-title"))
      ;;                   (PROG1 IT (SETF **A** A) (SETF **B** B))))
      ;;          (SB-KERNEL::ARG-COUNT-ERROR NIL)
      ;;          (SB-KERNEL::DEFMACRO-BOGUS-SUBLIST-ERROR NIL))), T
    #+END_SRC

    Вот так, к примеру, это можно совместить с поиском по дереву:

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (tree-match '("div"
                    (("class" "b-vacancy-custom g-round"
                      ("meta" (("itemprop" "title") ("content" "Ведущий android-разработчик")))
                      ("h1" (("class" "title b-vacancy-title")) "Ведущий android-разработчик")
                      ("table" (("class" "l"))
                               ("tr" NIL
                                     ("td" (("colspan" "2") ("class" "l-cell")))
                                     ("td" (("class" "l-cell")))))))
                    (("class" "g-round plus"))`
                    ("meta" (("itemprop" "title") ("content" "Ведущий android-разработчик"))))
                  (with-predict (a b &rest c)
                    (aif (and (stringp a)
                              (string= a "class"))
                         (prog1 it
                           (setf **a** a)
                           (setf **b** b))))
                  :return-all-match)
    #+END_SRC

    Для еще большей лаконичности мы можем определить оборачивающий макрос, который позволит
    нам не писать ничего, кроме условия в =aif=:

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defmacro with-predict-if (pattern &body condition)
        `(with-predict ,pattern
           (aif ,@condition
                (prog1 it
                  ,@(mapcar #'(lambda (x)
                                `(setf ,(intern (format nil "**~A**" (symbol-name x))) ,x))
                            (remove-if #'(lambda (x)
                                           (or (equal x '&rest)
                                               (equal x '&optional)
                                               (equal x '&body)
                                               (equal x '&key)
                                               (equal x '&allow-other-keys)
                                               (equal x '&environment)
                                               (equal x '&aux)
                                               (equal x '&whole)
                                               (equal x '&allow-other-keys)))
                                       (alexandria:flatten pattern)))))))

      ;; (macroexpand-1 '
      ;;  (with-predict-if (a b &rest c)
      ;;    (and (stringp a)
      ;;         (string= a "class"))))

      ;; => (WITH-PREDICT (A B &REST C)
      ;;      (AIF (AND (STRINGP A) (STRING= A "class"))
      ;;           (PROG1 IT
      ;;             (SETF **A** A)
      ;;             (SETF **B** B)
      ;;             (SETF **C** C))))
    #+END_SRC

    Таким образом мы инжектируем переменные шаблона в глобальную область видимости, если они
    не определены в более высокоуровневом =let=.

    Теперь мы можем вызывать =compile-pattern= так:

    #+BEGIN_SRC lisp
      (in-package #:moto)

      (print
       (tree-match '("div" (("class" "b-vacancy-custom g-round"))
                     ("meta" (("itemprop" "title") ("content" "Ведущий android-разработчик")))
                     ("h1" (("class" "title b-vacancy-title")) "Ведущий android-разработчик")
                     ("table" (("class" "l"))
                      ("tbody" NIL
                       ("tr" NIL
                             ("td" (("colspan" "2") ("class" "l-cell"))
                                   ("div" (("class" "employer-marks g-clearfix"))
                                          ("div" (("class" "companyname"))
                                                 ("a" (("itemprop" "hiringOrganization") ("href" "/employer/1529644"))
                                                      "ООО Нимбл"))))
                             ("td" (("class" "l-cell")))))))
                   (with-predict-if (a b &rest c)
                     (and (stringp a)
                          (string= a "class")))
                   :return-all-match))

      ;; => (("class" "b-vacancy-custom g-round") ("class" "title b-vacancy-title")
      ;;     ("class" "l") ("class" "l-cell") ("class" "employer-marks g-clearfix")
      ;;     ("class" "companyname") ("class" "l-cell"))

      (print **b**)
      ;; => "l-cell"
    #+END_SRC

***** Сопоставление и преобразование узлов
    Разбирая вакансию мы должны извлечь несколько блоков:
    - блок заголовка
    - общие данные, такие как уровень зарплаты, город, требуемый опыт работы
    - собственно описание вакансии
    Из каждого блока будем извлекать конкретные данные, возвращаемы как plist.

    Описание вакансии представляет из себя дерево, в котором нам важна структура, так как
    требования, обязанности и прочее описываются списком. В этом списке много лишнего
    форматирования, для удаления которого нам необходимо уметь преобразовывать дерево.

    Напишем для этого рекурсивный преобразователь, который возвращает новое дерево,
    рекурсивно вызывая аргумент =transformer= на =sub-tree=, которые удовлетворяют аргументу
    =predicate=.

    Аргумент =predicate= должен быть лямбда-функцией, которая принимает на вход =subtree= и
    возвращает T или NIL

    Аргумент =transformer= должен быть лямбда-функцией, которая принимает на вход =subtree= и
    возвращает =atom= или =subtree= в первом параметре, а во втором может возвратить функцию
    =control=. Если эта функция возвращена, тогда дерево возвращается с замененным
    =transformer=-ом узлами по следующему алгоритму:

    #+BEGIN_SRC lisp :exports none
      (funcall control
               #'(lambda (x)
                   (maptree-if predicate transformer x))
               transformed-tree)
    #+END_SRC

    В противном случае оно возвращается как есть.

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (defun maptree-if (predicate transformer tree)
        (multiple-value-bind (t-tree control)
            (if (funcall predicate tree)
                (funcall transformer tree)
                (values tree #'mapcar))
          (if (and (consp t-tree)
                   control)
              (funcall control
                       #'(lambda (x)
                           (maptree-if predicate transformer x))
                       t-tree)
              t-tree)))
    #+END_SRC

    Несколько примеров работы:

    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      ;; Нерекурсивная замена
      (maptree-if #'(lambda (x)
                      (and (consp x)
                           (eq (car x) 'ping)))
                  #'(lambda (x)
                      `(pong ,@(cdr x)))
                  '(progn (ping (ping (ping 1)))))
      ;; => (PROGN (PONG (PING (PING 1))))

      ;; Рекурсивная замена
      (maptree-if #'(lambda (x)
                      (and (consp x)
                           (eq (car x) 'ping)))
                  #'(lambda (x)
                      (values `(pong ,@(cdr x)) #'mapcar))
                  '(progn (ping (ping (ping 1)))
                    ping))
      ;; => (PROGN (PONG (PONG (PONG 1))))

      ;; Применение совместно с with-predict-if и использованием **переменных**
      (maptree-if #'(lambda (x)
                      (and (consp x)
                           (funcall (with-predict-if (a b &rest c)
                                      (and (equal b 'ping)))
                                    x)))
                  #'(lambda (x)
                      (values `(,**a** pong ,@(cddr x)) #'mapcar))
                  '(progn (ping (ping ping (ping 1)))
                    ping))
    #+END_SRC

    И макрос для более лаконичной записи того же:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (defmacro with-predict-maptree (pattern condition replace tree)
        (let ((lambda-param (gensym)))
          `(maptree-if #'(lambda (,lambda-param)
                           (and (consp ,lambda-param)
                              (funcall (with-predict-if ,pattern
                                         ,condition)
                                       ,lambda-param)))
                       ,replace
                       ,tree)))

      ;; (macroexpand-1
      ;;  '(with-predict-maptree (a b &rest c)
      ;;    (and (equal b 'ping))
      ;;    #'(lambda (x)
      ;;        (values `(,**a** pong ,@(cddr x)) #'mapcar))
      ;;    '(progn (ping (ping ping (ping 1))) ping)))

      ;; (with-predict-maptree (a b &rest c)
      ;;   (and (equal b 'ping))
      ;;   #'(lambda (x)
      ;;       (values `(,**a** pong ,@(cddr x)) #'mapcar))
      ;;   '(progn (ping (ping ping (ping 1))) ping))
    #+END_SRC

***** Разбор тизеров вакансий

    Теперь, чтобы получить вакансии со страниц поискоой выдачи - воспользуемся парсером,
    который переведет полученный html в более удобное лисп-дерево. Используя сопоставление с
    образцом мы раз за разом преобразуем его до тех пор, пока там не остануться только
    интересующие нас данные:
    - название вакансии
    - идентификатор (ссылку)
    - дату размещения
    - название работодателя
    - идентификатор работодателя

    Если в вакансии указана зарплата, мы также получаем
    - Валюту зарплаты (3х-буквенный идентификатор)
    - Сумму
    - Текстовое выражение, содержащее "от" или "от и до"

    Иногда HeadHunter синдицирует вакансии с других платформ, к примеру с CAREER.RU, тогда в
    вакансии может отсутствовать работодатель.

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun hh-parse-vacancy-teasers (html)
        "Получение списка вакансий из html"
        (let* ((tree (html5-parser:node-to-xmls (html5-parser:parse-html5-fragment html)))
               (searchblock (tree-match tree (with-predict-if (a ((b c) (d e)) &rest f)
                                               (string= c "search-result")))))
          (with-predict-maptree (a ((b class) (c d)) &rest z)
            (and (equal class "search-result"))
            #'(lambda (x) (values **z** #'mapcar))
            (with-predict-maptree (a ((b class) (c d)) &rest z)
              (and (or (equal class "search-result-item search-result-item_standard")
                       (equal class "search-result-item search-result-item_standard_plus")
                       (equal class "search-result-item search-result-item_premium search-result-item_premium")))
              #'(lambda (x) (values
                             (let ((in (remove-if #'(lambda (x) (or (equal x nil) (equal x "noindex") (equal x "/noindex"))) **z**))
                                   (rs))
                               (if (not (equal 1 (length in)))
                                   (err "parsing failed, data NOT printed") ;; (print in)
                                   (mapcar #'(lambda (item)
                                               (when (and (consp item)
                                                          (not (null item))
                                                          (keywordp (car item)))
                                                 (setf rs (append rs item))))
                                           (car in)))
                               rs)
                             #'mapcar))
              (with-predict-maptree (a (b c (d e) (f g)) h)
                (and (equal e "search-result-item__label HH-VacancyResponseTrigger-Text g-hidden")
                     (equal g "vacancy-serp__vacancy_responded")
                     (equal h "Вы откликнулись"))
                #'(lambda (x) (values nil #'mapcar))
                (with-predict-maptree  (a ((b  c ) (d  e) (f  g) (h i) (j k)) l)
                  (and (equal c "Премия HRBrand"))
                  #'(lambda (x) (values nil #'mapcar))
                  (with-predict-maptree (a ((b class)) logo)
                    (and (equal class "search-result-item__image"))
                    #'(lambda (x) (values nil #'mapcar))
                    (with-predict-maptree (a ((b class) (c d)))
                      (and (equal class "HH/VacancyResponseTrigger"))
                      #'(lambda (x) (values nil #'mapcar))
                      (with-predict-maptree (a ((b class) (c d)) z)
                        (and (equal class "search-result-item__label HH-VacancyResponseTrigger-Text g-hidden"))
                        #'(lambda (x) (values nil #'mapcar))
                        (with-predict-maptree (a ((b class)))
                          (and (equal class "search-result-item__star"))
                          #'(lambda (x) (values nil #'mapcar))
                          (with-predict-maptree (a ((b class)) c d e &optional f)
                            (and (equal class "search-result-item__description"))
                            #'(lambda (x) (values (remove-if #'null (list **c** **d** **e** **f**)) #'mapcar))
                            (with-predict-maptree (a ((b class)) (c ((d e) (f g) (h i) (j k)) z))
                              (and (equal class "search-result-item__head")
                                   (or  (equal e "search-result-item__name search-result-item__name_standard")
                                        (equal e "search-result-item__name search-result-item__name_standard_plus")
                                        (equal e "search-result-item__name search-result-item__name_premium")))
                              #'(lambda (x) (values (list :id **i** :name **z**) #'mapcar))
                              (with-predict-maptree (a ((b class) (c d)) (e ((f g) (h i))) (j ((k l) (m n))) z)
                                (and (equal class "b-vacancy-list-salary"))
                                #'(lambda (x) (values (list :currency **i** :salary **n** :salary-text **z**) #'mapcar))
                                (with-predict-maptree (a ((b class)) (c ((d e) (f g) (h i)) z))
                                  (and (equal class "search-result-item__company"))
                                  #'(lambda (x) (values (list :emp-id **e** :emp-name **z**) #'mapcar))
                                  (with-predict-maptree (a ((b class)) &rest rest)
                                    (and (equal class "search-result-item__info"))
                                    #'(lambda (x) (values (let ((rs))
                                                            (loop :for item :in **rest** :do
                                                               (when (and (consp item) (keywordp (car item)))
                                                                 (setf rs (append rs item))))
                                                            rs)
                                                          #'mapcar))
                                    (with-predict-maptree (c ((d sr-addr) (qa serp-addr)) city &rest rest)
                                      (and (equal sr-addr "searchresult__address")
                                           (equal serp-addr "vacancy-serp__vacancy-address"))
                                      #'(lambda (x) (values (let ((metro (loop :for item in **rest** :do
                                                                            (when (and (consp item) (equal :metro (car item)))
                                                                              (return (cadr item))))))
                                                              (list :city **city** :metro metro))
                                                            #'mapcar))
                                      (with-predict-maptree (a ((b class)) (c ((d metro-point) (i j))) metro)
                                        (and (equal class "metro-station")
                                             (equal metro-point "metro-point"))
                                        #'(lambda (x) (values (list :metro **metro**) #'mapcar))
                                        (with-predict-maptree (a ((b class) (c d)) date)
                                          (and (equal class "b-vacancy-list-date"))
                                          #'(lambda (x) (values (list :date **date**) #'mapcar))
                                          searchblock))))))))))))))))))

      (print
       (hh-parse-vacancy-teasers
        (hh-get-page "http://spb.hh.ru/search/vacancy?clusters=true&specialization=1.221&area=2&page=29")))
    #+END_SRC

***** Разбор вакансий

    Теперь, когда вся теоретическая подготовка проведена, можно заняться практикой и
    написать функцию, которая трансформирует описание, очищая его от всего лишнего:

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun transform-description (tree-descr)
        (let ((result)
              (header))
          (mapcar #'(lambda (item)
                      (unless (equal " " item)
                        (cond ((and (null header) (consp item) (equal 1 (length item)))
                               (setf header (car item)))
                              ((and (not (null header)) (consp item) (not (equal 1 (length item))))
                               (progn
                                 (setf result (append result (list (list header item))))
                                 (setf header nil)))
                              (t (setf result (append result (list item)))))))
                  (cddr
                   (with-predict-maptree (ul nil-1 &rest tail)
                          (and (or (equal ul "ul")
                                   (equal ul "p"))
                               (equal nil-1 'nil))
                          #'(lambda (x)
                              (values (remove-if #'(lambda (y)
                                                     (and (not (consp y)) (equal y " ")))
                                                 ,**tail**)
                                      #'mapcar))
                          (with-predict-maptree (tag nil-1 point)
                            (and (or (equal tag "li")
                                     (equal tag "em"))
                                 (equal nil-1 'nil))
                            #'(lambda (x)
                                (values **point** #'mapcar))
                            (with-predict-maptree (tag nil-1 point)
                              (and (equal tag "strong")
                                   (equal nil-1 'nil))
                              #'(lambda (x)
                                  (values **point** #'mapcar))
                              tree-descr)))))
          result))
    #+END_SRC

    И, наконец, применим все что мы подготовили, чтобы разобрать вакансию:

    #+NAME: hh_fn_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defun hh-parse-vacancy (html)
        "Получение вакансии из html"
        (let* ((tree (html5-parser:node-to-xmls (html5-parser:parse-html5-fragment html)))
               (header (tree-match tree (with-predict-if (a ((b c)) &rest d)
                                          (string= c "b-vacancy-custom g-round"))))
               (summary (tree-match tree (with-predict-if (a ((b c)) &rest d)
                                           (string= c "b-important b-vacancy-info"))))
               (infoblock (tree-match tree (with-predict-if (a ((b c)) &rest d)
                                             (string= c "l-content-2colums b-vacancy-container"))))
               (h1 (tree-match header (with-predict-if (a ((b c)) name &rest archive-block)
                                        (string= c "title b-vacancy-title"))))
               (employerblock (tree-match header (with-predict-if (a ((b c) (d emp-lnk)) emp-name)
                                                   (string= c "hiringOrganization"))))
               (salaryblock (tree-match summary (with-predict-if (a ((b c))
                                                                    (d ((e f) (g currency)))
                                                                    (h ((i j) (k base-salary)))
                                                                    salary-text)
                                                  (string= f "salaryCurrency"))))
               (cityblock (tree-match summary (with-predict-if (a ((b c)) (d ((e f)) city))
                                                (string= c "l-content-colum-2 b-v-info-content"))))
               (expblock (tree-match summary (with-predict-if (a ((b c) (d e)) exp)
                                               (string= e "experienceRequirements")))))
          (list :name **name**
                :archive (if (car (last (car **archive-block**))) t nil)
                :emp-name **emp-name**
                :emp-id (parse-integer (car (last (split-sequence:split-sequence #\/ **emp-lnk**))))
                :currency (if (null salaryblock) nil **currency**)
                :base-salary (if (null salaryblock) nil **base-salary**)
                :salary-text (if (null salaryblock) nil **salary-text**)
                :city **city**
                :exp **exp**
                :description (transform-description
                              (tree-match tree (with-predict-if (a ((b c) (d e)) &rest f)
                                                 (string= c "b-vacancy-desc-wrapper")))))))

      ;; (print
      ;;  (hh-parse-vacancy (hh-get-page "http://spb.hh.ru/vacancy/12325429")))

      ;; (print
      ;;  (hh-parse-vacancy (hh-get-page "http://spb.hh.ru/vacancy/12321429")))
    #+END_SRC

***** Сохранение данных

    Как только у нас это есть - код становится простым

    #+NAME: hh_parse
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (defparameter *programmin-and-development-profile*
        (make-profile :name "Программирование и разработка"
                      :user-id 1
                      :search-query "http://spb.hh.ru/search/vacancy?clusters=true&specialization=1.221&area=2&page=~A"
                      :ts-create (get-universal-time)
                      :ts-last (get-universal-time)))

      (defun run-collect (profile)
        (let* ((search-str   (search-query profile))
               (all-teasers  nil))
          (block get-all-hh-teasers
            (loop :for num :from 0 :to 100 :do
               (print num)
               (let* ((url (format nil search-str num))
                      (teasers (hh-parse-vacancy-teasers (hh-get-page url))))
                 (if (equal 0 (length teasers))
                     (return-from get-all-hh-teasers)
                     (setf all-teasers (append all-teasers teasers)))))
            (print "over-100"))
          all-teasers))

      ;; (print
      ;;  (hh-parse-vacancy-teasers (hh-get-page "http://spb.hh.ru/search/vacancy?clusters=true&specialization=1.221&area=2&page=28")))

      (defparameter *teasers* (run-collect *programmin-and-development-profile*))

      ;; (length *teasers*)

      (defun save-collect (all-teasers)
        (loop :for tea :in all-teasers :do
           (print tea)
           (make-vacancy :profile-id (id *programmin-and-development-profile*)
                         :name (getf tea :vac-name)
                         :rem-id (parse-integer
                                  (car (last (split-sequence:split-sequence
                                              #\/ (getf tea :vac-id)))))
                         :rem-date (getf tea :vacancy-date)
                         :rem-employer-name (getf tea :employer-name)
                         :rem-employer-id (aif (getf tea :employer-id)
                                               (parse-integer
                                                (car (last (split-sequence:split-sequence
                                                            #\/ it))))
                                               0)
                         :currency (getf tea :currency)
                         :salary (aif (getf tea :salary)
                                      it
                                      0)
                         :salary-text (getf tea :salary-text)
                         :state ":TEASER"
                         )))

      (save-collect *teasers*)

      ;; (length (all-vacancy))

      ;; (print
      ;;  (hh-parse-vacancy (hh-get-page (format nil "http://spb.hh.ru/vacancy/~A" (rem-id (get-vacancy 1))))))

      ;; (car *teasers*)
    #+END_SRC

    Теперь мы сохранили тизеры. Когда в интерфейсе мы определим, какие вакансии нас
    интересуют больше чем остальные их можно будет получить по статусу:

    #+NAME: hh_parse_deep
    #+BEGIN_SRC lisp
      (in-package #:moto)

      ;; (find-vacancy :profile-id 1)

      ;; (all-vacancy)
    #+END_SRC

**** TODO Анализ компаний

     Система анализирует компании с т.з. выставляемых вакансий и формирует профиль
     компании. По выставляемым вакансиям можно сделать интересные выводы - например когда у
     компании внезапно появляются вакансии на одного сеньера и нескольких линейных
     разработчиков - это напоминает открытие нового отдела/проекта.

*** TODO Классификация

    Система классифицирует сохраненные вакансии по формальным признакам, таким как:
    - новые вакансии
    - измененные
    - закрытые (о закрытости вакансии можно судить по ряду критериев)
    - особенно интересные
    - необычные

*** TODO Мониторинг

    В случае изменений или появления новых интересующих пользователя вакансий пользователю отправляется
    уведомление (через систему очередей сообщений и по email).

** Пользовательские
*** Авторизация/регистрация

    Пользователь регистрируется и авторизуется для получения доступа к своем аккаунту. За
    это отвечает модуль auth.

*** Формализация предпочтений

    Пользователь формулирует свои предпочтения относительно вакансий (и фирм их размещающих)
    в виде некоторых формализованных утверждений.

*** Отбор и сортировка вакансий

    Пользователь отбирает интересные и неинтересные ему вакансии вручную и автоматически -
    путем применения к ним скриптов

*** Внесение заметок к вакансиям

    Пользователь вносит свои соображения и заметки связанные с вакансией, или
    фирмой-работодателем

*** Заполнение резюме

    Пользователь заполняет резюме

*** Написание сопроводительных писем

    Пользователь пишет шаблоны сопроводительных писем, которые будут отправлены вместе с
    отзывом на вакансию

*** Отправка отзывов

    Пользователь отправляет отзыв на вакансию.



  Основные этапы:
  - Регистрация/логин (цель - войти на сайт)
  - Заполнение профиля (цель - определить поисковые запросы)
  - Написание резюме (несколько резюме, возможно под каждую особо-интересную вакансию)
  - Написание сопроводительных писем (тоже несколько, под вакансии)
  - Сбор тизеров по поисковому запросу
  - Ранжирование тизеров (положительный/отрицательный отсев)
  - Таггирование тизеров
  - Написание автоматических скриптов ранжирования по тегам (для продвинутых)
  - Сбор заинтересовавших вакансий (выше чем определенный ранг)
  - Ранжирование вакансий (положительный/отрицательный отсев)
  - Связывание с резюме и сопроводительными письмами
  - Отправка отзывов
  - Внесение заметок
  - Остальные переводы статуса и действия

  Зарегистрированный пользователь создает "поисковый профиль", в который заносит поисковый
  запрос и (в будущем) источники данных. Поля профиля описаны в секции [[Поисковые профили]].

  Потом он запрашивает сбор данных по этому поисковому профилю. Собираются тизеры
  вакансий. Если появились новые вакансии они добавляются в набор. Изменившиеся вакансии
  обновляются и помечаются как обновившиеся, не изменившиеся - не попадают в набор.

  После сбора данных пользователь просматривает набор и фильтрует его, отсеивая неинтересные
  вакансии, (которые скрываются) и помечая особенно понравившиеся (звездочкой).

  После фильтрации у отобранных вакансий скачиваются описания

  Выбрав вакансию, пользователь может оставить к ней заметки и начинает движение по графу состояний.

** Поисковые профили

   Разумеется, лучше собирать не все подряд, а только то что необходимо соискателю. Когда
   соискатель пользуется профильным сайтом он использует поисковые запросы, на основании
   которых мы можем формировать, гм... назовем это =поисковыми профилями=. Поисковый
   профиль - это запрос пользователя, плюс набор связанных с ним вакансий=.

   Вакансии на сайтах размещаются =компаниями= и привязываются к ним. Мне, как соискателю,
   интересно посмотреть какие вакансии размещала ранее конкретная компания, какие она
   размещает теперь, как изменялись зарплаты - и тому подобная аналитическая информация.

   Загрузка данных начинается с автоматического использования поиска. Мне интересны разные
   поисковые запросы - например, "веб-программист", "менеджер проекта", "руководитель
   отдела" и.т.п. По каждому из них можно составить поисковый профиль, который кроме текущих
   актуальных вакансий в нем содержит еще и "сборки" - с датой и временем получения данных и
   "изменения", т.е диффы между предыдущей сборкой и этой. Таким образом, например, можно
   отслеживать только что появляющиеся вакансии, которые часто представляют наибольший
   интерес.

   Мне бы хотелось осуществлять =сбор данных в многопоточном режиме=.

*** Список поисковых профилей

    Чтобы управлять поисковыми профилями нам понадобится страничка на которой их можно
    создать, удалить и просмотреть.

    #+NAME: iface_contents
    #+BEGIN_SRC lisp
      (in-package #:moto)

      (define-iface-add-del-entity all-profiles "/profiles"
        "Поисковые профили"
        "Новый профиль"
        "Когда соискатель пользуется профильным сайтом он использует
         поисковые запросы, на основании которых мы можем формировать,
         гм... назовем это =поисковыми профилями=. Поисковый профиль - это
         запрос пользователя, плюс набор связанных с ним вакансий"
         #'all-profile "profile"
        (name)
        (frm
         (tbl
          (list
           (row "Название" (fld "name"))
           (row "Запрос" (fld "search"))
           (row "" %new%))))
        (:new (act-btn "NEW" "" "Создать")
              (progn
                (make-profile :name (getf p :name)
                              :user-id 1
                              :search-query (getf p :search)
                              :ts-create (get-universal-time)
                              :ts-last (get-universal-time))
                "Профиль создан"))
        (:del (act-btn "DEL" (id i) "Удалить")
              (progn
                (del-profile (getf p :data)))))
    #+END_SRC

*** Страничка поискового профиля

    На страничке поискового профиля мы выводим все собранные по этому поисковому профилю
    вакансии. Будем считать что нас не особо интересуют вакансии без указания зарплаты,
    поэтому мы их просто отфильтровываем. После фильтрации сортируем в направлении уменьшения
    зарплаты.

    #+NAME: iface_contents
    #+BEGIN_SRC lisp

      (in-package #:moto)

      (defun vacancy-table (raw)
        (let ((vacs (sort (remove-if #'(lambda (x)
                                         (equal 0 (salary x)))
                                     raw)
                          #'(lambda (a b)
                              (> (salary a) (salary b))))))
          (format nil "<h2>Вакансий: ~A</h2>~%~A" (length vacs)
                  (tbl
                   (with-collection (vac vacs)
                     (tr
                      (td
                       (state vac))
                      (td
                       (format nil "<div style=\"background-color:green\">~A</div>"
                               (input "radio" :name (format nil "R~A" (id vac)) :value "y"
                                      :other (if (string= ":INTERESTED" (state vac)) "checked=\"checked\"" ""))))
                      (td
                       (format nil "<div style=\"background-color:red\">~A</div>"
                               (input "radio" :name (format nil "R~A" (id vac)) :value "n"
                                      :other (if (string= ":NOT_INTERESTED" (state vac)) "checked=\"checked\"" ""))))
                      (td (format nil "<a href=\"/vacancy/~A\">~A</a>" (id vac) (name vac)))
                      (td (salary-text vac))
                      (td (currency vac))))
                   :border 1))))

      (define-page profile "/profile/:userid"
        (let* ((i (parse-integer userid))
               (page-id (parse-integer userid))
               (u (get-profile i))
               (vacs (sort (remove-if #'(lambda (x)
                                          (equal 0 (salary x)))
                                      (find-vacancy :profile-id page-id))
                           #'(lambda (a b)
                               (> (salary a) (salary b))))))
          (if (null u)
              "Нет такого профиля"
              (format nil "~{~A~}"
                      (list
                       "<script>
                               function test (param) {
                                  $.post(
                                     \"/profile/1\",
                                     {act: param},
                                     function(data) {
                                        $(\"#dvtest\").html(data);
                                     }
                                 );
                               };
                        </script>"
                       (format nil "<h1>Страница поискового профиля ~A</h1>" (id u))
                       (format nil "<h2>Данные поискового профиля ~A</h2>" (name u))
                       (frm
                        (tbl
                         (with-element (u u)
                           (row "Имя профиля" (fld "name" (name u)))
                           (row "Запрос" (fld "search" (search-query u)))
                           (row (hid "profile_id" (id u)) %change%))
                         :border 1))
                       (tbl
                        (tr
                         (td %show-all%)
                         (td %show-interests%)
                         (td %show-not-interests%)
                         (td %show-other%)))
                       (frm %proceess-interests%)
                       (frm
                        (list
                         "<br /><br />"
                         %clarify%
                         "<div id=\"dvtest\">dvtest</div>"))))))
        (:change  (act-btn "CHANGE" "" "Изменить")
                  (id (upd-profile (get-profile (parse-integer userid))
                                   (list :name (getf p :name) :search-query (getf p :query)))))
        (:clarify (act-btn "CLARIFY" "" "Уточнить")
                  (loop :for key :in (cddddr p) :by #'cddr :collect
                     (let* ((val (getf p key))
                            (id  (parse-integer (subseq (symbol-name key) 1)))
                            (vac (get-vacancy id)))
                       (list id
                             (cond ((string= "y" val)
                                    (unless (string= ":INTERESTED" (state vac))
                                      (takt vac :interested)))
                                   ((string= "n" val)
                                    (unless (string= ":NOT_INTERESTED" (state vac))
                                      (takt vac :not_interested)))
                                   (t "err param"))))))
        (:show-all (format nil "<input type=\"button\" onclick=\"test('SHOW-ALL');\" value=\"все\">")
                   (error 'ajax :output (vacancy-table (find-vacancy :profile-id 1))))
        (:show-interests (format nil "<input type=\"button\" onclick=\"test('SHOW-INTERESTS');\" value=\"интересные\">")
                         (error 'ajax :output (vacancy-table (find-vacancy :state ":INTERESTED" :profile-id 1))))
        (:show-not-interests (format nil "<input type=\"button\" onclick=\"test('SHOW-NOT-INTERESTS');\" value=\"неинтересные\">")
                             (error 'ajax :output (vacancy-table (find-vacancy :state ":NOT_INTERESTED" :profile-id 1))))
        (:show-other (format nil "<input type=\"button\" onclick=\"test('SHOW-OTHER');\" value=\"остальные\">")
                     (error 'ajax :output (vacancy-table (remove-if #'(lambda (x)
                                                                        (or (string= ":NOT_INTERESTED" (state x) )
                                                                            (string= ":INTERESTED" (state x))))
                                                                    (find-vacancy :profile-id 1)))))
        (:proceess-interests (act-btn "PROCEESS-INTERESTS" "" "Собрать данные интересных вакансий")
                             "TODO"))

      ;; (profile-id (car (all-vacancy)))

      ;; (mapcar #'(lambda (x)
      ;;             (salary x))
      ;;         (find-vacancy :profile-id 1))

      ;; (car
      ;;  (remove-if #'(lambda (x)
      ;;                 (null (getf x :salary)))
      ;;             *teasers*))

      ;; (currency
      ;;  (car
      ;;   (remove-if #'(lambda (x)
      ;;                  (equal (salary x) 0))
      ;;              (all-vacancy))))
    #+END_SRC

** Поиск вакансий

   Внутри вакансий необходимо искать по критериям, которые я уточню позже

   Мне хотелось бы чтобы вакансии были упорядочены по зарплате

   Мне бы хотелось сразу получать представление, насколько свежая вакансия

   Мне было бы интересно, сколько интервью было проведено и запланировано по вакансии - эту
   информацию можно узнать из анализа активности по ней других пользователей

   Мне было бы интересно, как менялась вакансия с момента ее размещения компанией - можно
   находить и отслеживать похожие вакансии по расстоянию Левенштейна в описании, к
   примеру. Динамика изменения зарплатного предложения может многое сказать об отношении к
   вакансии.

** Ручной отбор вакансий
** Автоматический отбор вакансий
** Внесение заметок по вакансии
** Просмотр и отбор вакансий, заметки и выставление статусов

   Когда я читаю вакансию, я бы хотел, чтобы она переходила в статус "просмотрено" (и к ней
   добавлялась дата просмотра)

   Читая вакансию, мне бы хотелось устанавливать ей приоритет и вносить заметки, чтобы
   отслеживать такие моменты, как например: необходимость позвонить позже, или все, что мне
   сказал hr по телефону. Есть типовые вещи, которые можно просто сделать кнопками.

   Если я отправляю отзыв на вакансию или звоню по телефону - я бы хотел, чтобы эти действия
   сопровождались временем и изменением статуса, чтобы потом можно было отследить историю
   взаимодействия с фирмой.

   При этом, мне хотелось бы видеть на дашборде те вакансии, с которыми я договорился о
   встрече и те, по которым нет движения долгое время, чтобы ничего не забывалось.

** Дашборд

   Если у нас есть формализованный алгоритм (а он есть, так как найм - это линейный
   процесс), то я хочу получать напоминания о моем следующем шаге в отношении тех вакансий,
   которые мне интересны.

   Мне бы хотелось видеть на каком я этапе в тех вакансиях, которые меня интересуют.

** Отзывы соискателей о компаниях и вакансиях

   Можно сэкономить кучу времени и денег просто не нанимаясь в те компании, в которых "все
   плохо". В этом плане соискатели могут помоч друг другу. Возможно и компании тоже будут
   прислушиваться к такому фидбеку

** Размещение резюме

   Пользователь просто размещает свое резюме. На самом деле - несколько резюме, так как
   наиболее продвинутые пользователи пишут резюме под вакансию, а не рассылают одно и то же
   резюме всем подряд

** Маршрут

   Иногда я хочу спланировать маршрут поездки по собеседованиям. Это сервис с картами,
   которые можно сделать позже.

** Создание вакансии работодателем
** Вакансия становится неактуальной

   Вакансия может стать неактуальной если работодатель снимет ее, но работодатели могут
   забывать это сделать, поэтому можно предусмотреть тайм-аут или даже некоторое кол-во
   голосов соискателей, которые дозвонились но им сказали, что вакансия уже неактуальна.

* Сущности
** Поисковые профили

   #+CAPTION: Данные поискового профиля
   #+NAME: profile_flds
     | field name   | field type | note                                      |
     |--------------+------------+-------------------------------------------|
     | id           | serial     | идентификатор                             |
     | user-id      | integer    | владелец и создатель                      |
     | name         | varchar    | название профиля                          |
     | search-query | varchar    | поисковый запрос                          |
     | ts-create    | bigint     | время создания                            |
     | ts-last      | bigint     | время когда был использован последний раз |

** Вакансии

   #+CAPTION: Данные вакансии
   #+NAME: vacancy_flds
     | field name        | field type           | note                                                        |
     |-------------------+----------------------+-------------------------------------------------------------|
     | id                | serial               | идентификатор                                               |
     | profile-id        | integer              | идентификатор поискового профиля                            |
     | name              | varchar              | название вакансии                                           |
     | rem-id            | integer              | идентификатор вакансии на удаленном ресурсе                 |
     | rem-date          | varchar              | дата создания вакансии на удаленном ресурсе                 |
     | rem-employer-name | varchar              | имя работодателя на удаленном ресурсе                       |
     | rem-employer-id   | (or db-null integer) | идентификатор работодателя на удаленном ресурсе             |
     | currency          | (or db-null varchar) | валюта зарплаты                                             |
     | salary            | (or db-null integer) | размер компенсации                                          |
     | salary-text       | (or db-null varchar) | размер компенсации                                          |
     | contact           | (or db-null varchar) | телефон контактного лица                                    |
     | text              | (or db-null varchar) | описание вакансии                                           |
     | history           | (or db-null varchar) | список изменения статусов со временем каждого изменения     |
     | reason            | (or db-null varchar) | добавляем причину действия (позже ссылка на другую таблицу) |
     | ts-created        | (or db-null bigint)  | время создания вакансии                                     |
     | ts-viewed         | (or db-null bigint)  | время когда вакансия была просмотрена                       |


   Вакансии могут появляться у нас следующими путями:
   - Работодатель может создать вакансию
   - Мы можем получить вакансию анализируя другой сайт

   В случае, если мы получаем вакансию анализируя другой сайт, мы получаем ее в 2 этапа. На
   первом этапе мы разобрали т.н. "тизер вакансии" и занесли ее в базу данных в состоянии
   =teaser=, чтобы потом получить все остальные данные. На втором этапе мы получаем данные
   со страницы вакансии и устанавливаем состояние =new=.

   Если пользователю не нравится тизер и он решает скрыть вакансию - она сразу из состояния
   =teaser= попадает в состояние =not_interested=.

   Если же пользователю наоборот, нравится вакансия, она из состояния =teaser= попадает в
   состояние =interested=.

   Когда вакансия переносится в архив - мы должны отслеживать это на стороннем сайте и
   реагировать, устанавливая статус =archive=

   TODO: Конечный автомат тут сложен и будет еще уточняться... Пока состояния такие:
    =просмотрено= (с датой), =отобрано=, =не-берут-трубку=, =не-актуально=,
    =приглашен-на-интервью=, =тестовое-задание=, =получен-оффер=, =отказано-работодателем=,
    =отказ-соискателя=, =вакансия-снята= итп.

   Когда мы собираем вакансии, распарсивая их с других сайтов, мы должны отслеживать их
   состояние на этих сайтах. Мы узнаем о вакансии, ко

** Перекрестные связи с другими вакансиями

   В ряде случаев компании меняют свои вакансии, некоторые делают это методом удаления
   предыдущей и создания новой. Мне как соискателю хотелось бы не обнаруживать уже
   просмотренную и возможно собеседованную вакансию в новых. Поэтому хотелось бы
   предусмотреть механизм, который связывает очень похожие вакансии друг с другом.

   Иногда вакансии меняются, или в них меняются существенные условия. Например, две недели
   назад, когда я смотрел вакансию из предыдущей сборки меня не устроила зарпалата, а
   сегодня вакансия стала интереснее. Я хочу отслеживать что вакансия поменялась.

   Таким образом при создании вакансии мы должны проверять, может она уже есть в базе и
   тогда указывать, что эта вакансия включена в несколько сборок (требует таблицы связи)

** Компании

   Несколько вакансий могут быть от одной компании. В этом случае мне бы хотелось
   отслеживать это в профиле компании, кроме того интересна аналитика по этой компании за
   определенный период времени.

   С социальной точки зрения интересно получать отзывы о компании от ее работников, в том
   числе и уволенных.

** Действия по вакансии: звонки, скайп-интервью, собеседования

   В эту таблицу заносим что сделано по каждой вакансии, которая находится в разработке

** Теги вакансий

   Помогают ориентироваться, когда вакансий много.

* Interface

  Соберем веб-интерфейс:

  #+NAME: iface
  #+BEGIN_SRC lisp :tangle src/mod/hh/iface.lisp :noweb tangle :exports none :padline no :comments link
    ;;;; iface.lisp

    (in-package #:moto)

    ;; Страницы
    <<iface_contents>>
  #+END_SRC

** Главная страница модуля
   #+NAME: iface_contents
   #+BEGIN_SRC lisp

     (in-package #:moto)

     (restas:define-route hh-main ("/hh")
       (with-wrapper
           "<h1>Главная страница HH</h1>"
         ))
   #+END_SRC

** Галлерея (parenscript)

   #+NAME: iface_contents
   #+BEGIN_SRC lisp
     (defparameter *slideshows* (make-hash-table :test 'equalp))

     (defun add-slideshow (slideshow-name image-folder)
       (setf (gethash slideshow-name *slideshows*)
             (mapcar (lambda (pathname)
                       (url-encode (format nil "~a.~a"
                                           (pathname-name pathname)
                                           (pathname-type pathname))))
                     (list-directory image-folder))))

     (add-slideshow "img" "/home/rigidus/repo/moto/img/")
     (add-slideshow "pic" "/home/rigidus/repo/moto/pic/")

     (alexandria:hash-table-plist *slideshows*)

     (defmacro/ps slideshow-image-uri (slideshow-name image-file)
       `(concatenate 'string ,slideshow-name "/" ,image-file))

     (restas:define-route y ("y")
       (ps
         (define-symbol-macro fragment-identifier (@ window location hash))
         (defun show-image-number (image-index)
           (let ((image-name (aref *images* (setf *current-image-index* image-index))))
             (setf (chain document (get-element-by-id "slideshow-img-object") src)
                   (slideshow-image-uri *slideshow-name* image-name)
                   fragment-identifier
                   image-name)))
         (defun previous-image ()
           (when (> *current-image-index* 0)
             (show-image-number (1- *current-image-index*))))
         (defun next-image ()
           (when (< *current-image-index* (1- (getprop *images* 'length)))
             (show-image-number (1+ *current-image-index*))))
         ;; this gives bookmarkability using fragment identifiers
         (setf (getprop window 'onload)
               (lambda ()
                 (when fragment-identifier
                   (let ((image-name (chain fragment-identifier (slice 1))))
                     (dotimes (i (length *images*))
                       (when (string= image-name (aref *images* i))
                         (show-image-number i)))))))))

     (defun slideshow-handler (slideshow-name)
       (let* ((images (gethash slideshow-name *slideshows*))
              (current-image-index (or (position (get-parameter "image") images :test #'equalp)
                                       0))
              (previous-image-index (max 0 (1- current-image-index)))
              (next-image-index (min (1- (length images)) (1+ current-image-index))))
         (with-html-output-to-string (s)
           (:html
            (:head
             (:title "Parenscript slideshow")
             (:script :type "text/javascript"
                      (str (ps* `(progn
                                   (var *slideshow-name* ,slideshow-name)
                                   (var *images* (array ,@images))
                                   (var *current-image-index* ,current-image-index)))))
             (:script :type "text/javascript" :src "/y")
             )
            (:body
             (:div :id "slideshow-container"
                   :style "width:100%;text-align:center"
                   (:img :id "slideshow-img-object"
                         :src (slideshow-image-uri slideshow-name
                                                   (elt images current-image-index)))
                   :br
                   (:a :href (format nil "?image=~a" (elt images previous-image-index))
                       :onclick (ps (previous-image) (return false))
                       "Previous")
                   " "
                   (:a :href (format nil "?image=~a" (elt images next-image-index))
                       :onclick (ps (next-image) (return false))
                       "Next")
                   ))))))

     (restas:define-route x ("/x")
       (slideshow-handler "pic"))

     (restas:define-route z ("/z")
       (slideshow-handler "img"))
   #+END_SRC

** Список вакансий

   Мне бы хотелось иметь интерфейс для того чтобы управлять собранными элементами - в первую
   очередь ранжировать их по интересности. Для этого, мне нужно уметь перемещать эти
   элементы в коллекции.

   Но перед этим мне нужно сделать отображение этих элементов через ajax

   #+NAME: iface_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     (defmacro/ps s+ (&body body)
       `(concatenate 'string ,@body))

     (defmacro/ps btn+ (name value onclick)
       `(s+ "<input type='button' name='" ,name
            "' value='" ,value
            "' onclick='" ,onclick
            ";return false;' />"))

     (defmacro/ps asm+ (id name salary-text)
       `(s+ "<li id=\"" ,id "\">"
            "<span class=\"handle\">&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;"
            ,name
            "&nbsp;"
            "<span style='color: red'>" ,salary-text "</span>"
            "</li>"))

     (restas:define-route collection ("/collection")
       (labels ((asm-node (x)
                  (asm+ (format nil "~A" (id x))
                        (name x)
                        (let ((it (salary-text x)))
                          (if (equal it "false") "" it))))
                (mrg (param)
                  (if (null param)
                      (ps-html ((:li :id 0)
                                "Нет вакансий"))
                      (reduce #'(lambda (x y)
                                  (concatenate 'string x (string #\NewLine) y))
                              (mapcar #'(lambda (x)
                                          (asm-node x))
                                      param)))))
         (let* ((vacs (aif (find-vacancy :profile-id 1) it (err "null vacancy")))
                (sorted-vacs (sort vacs #'(lambda (a b) (> (salary a) (salary b)))))
                (not-interesting)
                (interesting)
                (unsort))
           (loop :for vac :in sorted-vacs :do
              (if (equal 0 (salary vac))
                  (setf not-interesting (append not-interesting (list vac)))
                  (if (or (search "android" (string-downcase (name vac)))
                          (search ".net" (string-downcase (name vac)))
                          (search "python" (string-downcase (name vac)))
                          (search "javascript" (string-downcase (name vac)))
                          (search "с#" (string-downcase (name vac)))
                          (search "с++" (string-downcase (name vac)))
                          (search "ruby" (string-downcase (name vac)))
                          (search "SAP" (name vac))
                          (search "1С" (name vac))
                          (search "QA" (name vac))
                          (search "objective-c" (string-downcase (name vac)))
                          (search "ios" (string-downcase (name vac)))
                          (search "delphi" (string-downcase (name vac)))
                          (search "sharepoint" (string-downcase (name vac)))
                          (search "flash" (string-downcase (name vac)))
                          (search "windows" (string-downcase (name vac)))
                          (search "pl/sql" (string-downcase (name vac)))
                          (search "front-end" (string-downcase (name vac)))
                          (and (equal "RUR" (currency vac))
                               (> 50000 (salary vac)))
                          )
                      (setf not-interesting (append not-interesting (list vac)))
                      (if (or (search "php" (string-downcase (name vac)))
                              (search "java" (string-downcase (name vac)))
                              (search "web" (string-downcase (name vac)))
                              (search "backend" (string-downcase (name vac)))
                              (search "back-end" (string-downcase (name vac)))
                              )
                          (setf interesting (append interesting (list vac)))
                          ;; (setf unsort (append unsort (list vac)))
                          ))))
           (with-wrapper
             (ps-html
              ((:link :href "/css/dnd.css" :rel "stylesheet" :media "all"))
              ((:script :src "/js/jquery.sortable.js"))
              ;; (:script (ps
              ;;            (defun up (id)
              ;;              (let* ((obj ((@ $) (+ "#tr" id))))
              ;;                ((@ obj after) ((@ obj prev)))))
              ;;            (defun down (id)
              ;;              (let* ((obj ((@ $) (+ "#tr" id))))
              ;;                ((@ obj before) ((@ obj next)))))
              ;;            (defun asm-teaser (i id name state salary salary-text currency)
              ;;              (s+ "<li id='tr" id "'>"
              ;;                  (s+ "<li>" name "</td>")
              ;;                  "</li>"))
              ;;            (defun load-elts (param)
              ;;              ((@ $ post) "/collection" (create :act param)
              ;;               (lambda (data)
              ;;                 ((@ ((@ $) "#vacancy-container")  html) "")
              ;;                 ((@ $ each) data
              ;;                  (lambda (i data)
              ;;                    ((@ ((@ $) "#vacancy-container")  append)
              ;;                     (asm-teaser i (@ data id) (@ data name) (@ data state)
              ;;                                 (@ data salary) (@ data salary-text) (@ data currency))))))
              ;;               :json))))
              ((:table :border 0)
               ((:tr)
                ((:td)
                 ((:textarea :name "code" :id "code" :rows 20 :cols 160)
                  (ps
                    (defun load-elts (param)
                      ((@ $ post) "/collection" (create :act param)
                       (lambda (data)
                         ((@ ((@ $) "#vacancy-container")  html) "")
                         ((@ $ each) data
                          (lambda (i data)
                            ((@ ((@ $) "#vacancy-container")  append)
                             (s+ "<li id='" (@ data id) "'>" (@ data name) "</li>")))))
                       :json))
                    (defun vac-hook (vac)
                      ;; (if (equal 0 (salary vac))
                      ;;     (setf not-interesting (append not-interesting (list vac)))
                      ;;     (if (or (search "android" (string-downcase (name vac)))
                      ;;             (search ".net" (string-downcase (name vac)))
                      ;;             (search "python" (string-downcase (name vac)))
                      ;;             (search "javascript" (string-downcase (name vac)))
                      ;;             (search "с#" (string-downcase (name vac)))
                      ;;             (search "с++" (string-downcase (name vac)))
                      ;;             (search "ruby" (string-downcase (name vac)))
                      ;;             (search "SAP" (name vac))
                      ;;             (search "1С" (name vac))
                      ;;             (search "QA" (name vac))
                      ;;             (search "objective-c" (string-downcase (name vac)))
                      ;;             (search "ios" (string-downcase (name vac)))
                      ;;             (search "delphi" (string-downcase (name vac)))
                      ;;             (search "sharepoint" (string-downcase (name vac)))
                      ;;             (search "flash" (string-downcase (name vac)))
                      ;;             (search "windows" (string-downcase (name vac)))
                      ;;             (search "pl/sql" (string-downcase (name vac)))
                      ;;             (search "front-end" (string-downcase (name vac)))
                      ;;             (and (equal "RUR" (currency vac))
                      ;;                  (> 50000 (salary vac)))
                      ;;             )
                      ;;         (setf not-interesting (append not-interesting (list vac)))
                      ;;         (if (or (search "php" (string-downcase (name vac)))
                      ;;                 (search "java" (string-downcase (name vac)))
                      ;;                 (search "web" (string-downcase (name vac)))
                      ;;                 (search "backend" (string-downcase (name vac)))
                      ;;                 (search "back-end" (string-downcase (name vac)))
                      ;;                 )
                      ;;             (setf interesting (append interesting (list vac)))
                      ;;             (setf unsort (append unsort (list vac)))
                      ;;             )))
                      )
                    (load-elts "stub")
                    )))
                ((:td)
                 ((:a :onclick "loadElts(1); return false") "loadElts(1);")
                 (:br)
                 ((:a :onclick "eval($('#code').val()); return false;") "eval #code")
                 (:br)
                 ((:a :onclick "alert(getChildIds('#interesting-container')); return false;") "childs")
                 (:br)
                 ((:a :onclick "$('.connected').sortable('destroy'); return false;") "destroy")
                 (:br)
                 ((:a :onclick "$('.connected').sortable({ connectWith: '.connected', handle: '.handle'}); return false;") "make")
                 (:br))))
              ((:table :border 0 :style "font-size: small;")
               ((:th) "Интересные")
               ((:th) "Неразобранные")
               ((:th) "Неинтересные")
               ((:tr)
                ((:td :width 500 :valign "top")
                 ((:ul :class "connected" :id "interesting-container")
                  (mrg interesting)))
                ((:td :width 500 :valign "top")
                 ((:ul :class "connected" :id "unsort-container")
                  (mrg unsort)))
                ((:td :width 500 :valign "top")
                 ((:ul :class "connected" :id "not-interesting-container")
                  (mrg not-interesting))))))))))



     (restas:define-route collection-post ("/collection" :method :post)
       ;; TODO: Тут перед кодированием можно убирать из пересылаемых данных лишние поля, чтобы не слать их по сети
       (with-wrapper
         (error 'ajax :output (cl-json:encode-json-to-string
                               (aif (find-vacancy :profile-id 1)
                                    it
                                    (err "null vacancy"))))))
   #+END_SRC

http://isocra.com/2008/02/table-drag-and-drop-jquery-plugin/
http://romka.eu/blog/jquery-table-drag-and-drop

** Дашборд
* Тесты

  #+NAME: hh_test
  #+BEGIN_SRC lisp :noweb tangle :exports none

    ;; Тестируем hh
    (defun hh-test ()
      <<hh_test_contents>>
      (dbg "passed: hh-test~%"))
    (hh-test)
  #+END_SRC

  #+NAME: hh_test_contents
  #+BEGIN_SRC lisp :noweb tangle :exports none

  #+END_SRC
* Точки входа

  Соберем шаблоны:

  #+NAME: hh_tpl
  #+BEGIN_SRC closure-template-html :tangle src/mod/hh/hh-tpl.htm :noweb tangle :exports none
    // -*- mode: closure-template-html; fill-column: 140 -*-
    {namespace hhtpl}

    <<hhtpl_contents>>
  #+END_SRC

  Скомпилируем шаблоны при подготовке модуля

  #+NAME: hh_prepare
  #+BEGIN_SRC lisp :tangle src/mod/hh/hh-prepare.lisp :noweb tangle :exports none
    (in-package #:moto)

    ;; Скомпилируем шаблон
    (closure-template:compile-template
     :common-lisp-backend
     (pathname
      (concatenate 'string *base-path* "mod/hh/hh-tpl.htm")))
  #+END_SRC

  Соберем контроллеры и все функции, которые контроллеры вызывают

  #+NAME: hh_fn
  #+BEGIN_SRC lisp :tangle src/mod/hh/hh.lisp :noweb tangle :exports none
    (in-package #:moto)

    <<hh_fn_contents>>

    <<hh_parse>>

    <<hh_test>>
  #+END_SRC

* Сборка
** Фунциональные утилиты

   #+NAME: f_util
   #+BEGIN_SRC lisp :tangle src/mod/hh/f-util.lisp :noweb tangle :exports none :padline no :comments link
     (in-package #:moto)

     <<f_util_contents>>
   #+END_SRC

*** Point-free определения:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (defmacro define (form* form)
        (etypecase form*
          (symbol (etypecase form
                    ;; alias for function or macro
                    (symbol `(defmacro ,form* (&rest args)
                               `(,',form ,@args)))
                    ;; alias for lambda
                    (cons   `(defun ,form* (&rest args)
                               (apply ,form args)))))
          (cons     ;; scheme-like function definition
           ` (defun ,(first form*) ,(rest form*)
               ,form))))
    #+END_SRC

    Тут typecase используется до генерации кода - в зависимости от того символы или списки
    связываются друг с другом генерируются различные определения. Можно определять
    псевдонимы для функций и маросов, псевдоним будет макросом:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (define head car)
      (define tail cdr)
      (define \\   lambda)
      (define $    funcall)
    #+END_SRC

    Можно определить функцию f2, которая является псевдонимом для лямбды, возвращённой
    формой (f1 a1):

    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (define f2 (f1 a1))
      (f2 a2) ~ (apply (f1 a1) a2)
    #+END_SRC

    Простое определение функций в Scheme-стиле, более соответствующее представлению о
    редукции форм:

    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (define (f1 a1) (f2 a2))
      (f1 a1) ~ (defun f1 (a1) (f2 a2))
    #+END_SRC

    Также, чтобы определять функции миксующую аргументы с другой функцией, можно ввести
    такой макрос:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (defmacro define* (form* form)
        `(defun ,(first form*) ,(rest form*)
           (,(first form) ,@(rest form) ,@(rest form*))))
    #+END_SRC

    Пример:

    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (define* (f1 a1) (f2 a2))
      (f1 a1) ~ (f2 a2 a1)
    #+END_SRC

    Либо использовать карринг.

*** Flip, карринг, композиции:

    далее f, g, ... обозначают функции,
          a, b, ... - их аргументы.

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (define (self object) object)
      (define (flip f)      (\\ (a b) ($ f b a)))
      (define (curry f a)   (\\ (b)   ($ f a b)))
      (define (curry* f g)  (\\ (a b) ($ f g a b)))
      (define (compose f g) (\\ (a)   ($ f ($ g a))))
    #+END_SRC

*** Свёртки и "развёртки":

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      (define (foldl f a list)
          (typecase list
            (null a)
            (cons (foldl f ($ f a (head list)) (tail list)))))

      (define (foldr f a list)
          (typecase list
            (null a)
            (cons ($ f (head list) (foldr f a (tail list))))))

      (define (unfold f i p)
          (if ($ p i)
              (cons i '())
              (cons i (unfold f ($ f i) p))))

      (define fold foldl)
      (define my-reduce fold)
    #+END_SRC

*** Отображения и фильтрации:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      ;; map & filter
      (define (my-map f list) (foldr (\\ (x y) (cons ($ f x) y)) '() list))
      (define (filter p list) (foldr (\\ (x y) (if ($ p x) (cons x y) y)) '() list))
    #+END_SRC

*** Функции для списков на основе карринга и свёрток:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      ;; functions for lists
      (define (my-list &rest objs)         objs)
      (define (my-length list)             (fold (\\ (x y) (1+ x)) 0 list))
      (define (my-reverse list)            (fold (flip 'cons) '() list))
      (define (my-append list &rest lists) (fold (flip (curry* 'foldr 'cons)) list lists))
    #+END_SRC

*** Функции для чисел:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      ;; functions for numbers
      (define zero?                    (curry '= 0))
      (define positive?                (curry '< 0))
      (define negative?                (curry '> 0))
      (define (odd? number)            (= (mod number 2) 1))
      (define (even? number)           (= (mod number 2) 0))
      (define (my-max a &rest numbers) (fold (\\ (y z) (if (> y z) y z)) a numbers))
      (define (my-min a &rest numbers) (fold (\\ (y z) (if (< y z) y z)) a numbers))
      (define (summa &rest numbers)    (fold '+ 0 numbers))
      (define (product &rest numbers)  (fold '* 1 numbers))
    #+END_SRC

*** И для булевых чисел:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      ;; functions for booleans
      (define (my-and &rest list)   (fold 'and t list))
      (define (my-or &rest list)    (fold 'or nil list))
      (define (any? p &rest list)   (apply 'my-or (my-map p list)))
      (define (every? p &rest list) (apply 'my-and (my-map p list)))

    #+END_SRC

*** Многие другие функции представляются свёртками, например:

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      ;; member & assoc
      (flet ((helper (p op)
               (\\ (a next) (if (and (not a) ($ p ($ op next))) next a))))

        (define (my-member object list &key (test 'equal))
            (fold (helper (curry test object) 'self) nil list))

        (define (my-assoc object alist &key (test 'equal))
            (fold (helper (curry test object) 'car) nil alist)))
   #+END_SRC

*** Свёртки для деревьев:

    Теперь, собственно, код для деревьев. Нужно заметить, что учитывая весь код для
    "абстракций", получается существенно меньше, чем при реализации "в лоб" (как у Грэхама,
    например).

    #+NAME: f_util_contents
    #+BEGIN_SRC lisp :exports none
      (in-package #:moto)

      ;; for (1 . (2 . 3)) trees

      (define (my-append a b)
          (append (if (atom a) (list a) a)
                  (if (atom b) (list b) b)))

      (define (fold-tree f g tree)
          (typecase tree
            (atom ($ f tree))
            (cons ($ g (fold-tree f g (head tree))
                     (fold-tree f g (tail tree))))))

      (define* (summa/tree tree) (fold-tree 'self '+))
      (define* (depth/tree tree) (fold-tree 'one 'max+1))
      (define* (flatten tree)    (fold-tree 'self 'my-append))

    #+END_SRC

** Другие утилиты

   #+NAME: f_util_contents
   #+BEGIN_SRC lisp :exports none
     (in-package #:moto)

     ;; (defun my-range (n)
     ;;   (let ((i 0))
     ;;     #'(lambda ()
     ;;         (if (< i n) (incf i) nil))))

     ;; (let ((f (my-range 3)))
     ;;   (list
     ;;    (funcall f)
     ;;    (funcall f)
     ;;    (funcall f)
     ;;    (funcall f)
     ;;    (funcall f)
     ;; ))

     ;; (range 3)

     ;; (defmacro do-closure ((i clos) &body body)
     ;;   (let ((c (gensym)))
     ;;     `(let ((,c ,clos))
     ;;        (loop for ,i = (funcall ,c)
     ;;           while ,i do ,@body))))

     ;; (do-closure (i (my-range 100)) (print i))


     (declaim (inline zip))
     (defun zip (&rest args)
       "
     Zips the elements of @arg{args}.
     Example:
     @lisp
     > (zip '(2 3 4) '(a b c) '(j h c s))
     => ((2 A J) (3 B H) (4 C C))
     @end lisp
     "
       (apply #'map 'list #'list args))

     (defun symstuff (l)
       "From the Common Lisp Cookbook - http://cl-cookbook.sourceforge.net/macros.html
     Helper function to (build-symbol)"
       `(concatenate 'string
                     ,@(for (x :in l)
                            (cond ((stringp x)
                                   `',x)
                                  ((atom x)
                                   `',(format nil "~a" x))
                                  ((eq (car x) ':<)
                                   `(format nil "~a" ,(cadr x)))
                                  ((eq (car x) ':++)
                                   `(format nil "~a" (incf ,(cadr x))))
                                  (t
                                   `(format nil "~a" ,x))))))

     (defmacro build-symbol (&rest l)
       "From the Common Lisp Cookbook - http://cl-cookbook.sourceforge.net/macros.html"
       (let ((p (find-if (lambda (x) (and (consp x) (eq (car x) ':package)))
                         l)))
         (cond (p
                (setq l (remove p l))))
         (let ((pkg (cond ((eq (cadr p) 'nil)
                           nil)
                          (t `(find-package ',(cadr p))))))
           (cond (p
                  (cond (pkg
                         `(values (intern ,(symstuff l) ,pkg)))
                        (t
                         `(make-symbol ,(symstuff l)))))
                 (t
                  `(values (intern ,(symstuff l))))))))

     (defun remove-nth (n seq)
       "Remove nth element from sequence"
       (remove-if (constantly t) seq :start n :count 1))

     (defun make-hash (&rest keyvals)
       "Create a hash table given keys and values"
       (plist-hash-table keyvals))

     (defmacro make-hash* (&rest keyvals)
       "Make a hash table given key/value pairs, allowing use of prior key/val pairs in late r definitions"
       (loop while keyvals
          for k = (intern (symbol-name (pop keyvals)))
          for v = (pop keyvals)
          collect `(,k ,v) into letargs
          collect (make-keyword k) into objargs
          collect k into objargs
          finally (return
                    `(let* (,@letargs)
                       (make-hash ,@objargs)))))

     (defun maphash2 (fn ht)
       "Returns a hash-table with the results of the function of key & value as values"
       (let ((ht-out (make-hash-table
                      :test (hash-table-test ht)
                      :size (hash-table-size ht)
                      :rehash-size (hash-table-rehash-size ht)
                      :rehash-threshold (hash-table-rehash-threshold ht))))
         (maphash #'(lambda (k v)
                      (setf (gethash k ht-out) (funcall fn k v)))
                  ht)
         ht-out))

     (defun maphash-values2 (fn ht)
       "Returns a hash-table with the results of the function of value as values"
       (let ((ht-out (make-hash-table)))
         (maphash #'(lambda (k v) (setf (gethash k ht-out) (funcall fn v))) ht)
         ht-out))

     (defmacro swap (pl1 pl2)
       "Macro to swap two places"
       (let ((temp1-name (gensym)) ; don't clobber existing names
             (temp2-name (gensym)))
         `(let ((,temp1-name ,pl1)
                (,temp2-name ,pl2))
            (setf ,pl1 ,temp2-name)
            (setf ,pl2 ,temp1-name))))

     (defun print-hash-key-or-val (kv stream)
       (format stream (typecase kv
                        (keyword " :~a")
                        (string " \"~a\"")
                        (symbol " '~a")
                        (list " '~a")
                        (t " ~a")) kv))

     (defun printhash (h &optional (stream t))
       "Pretty print a hash table as :KEY VAL on separate lines"
       (format stream "#<HASH-TABLE~{~a~a~^~&~}>"
               (loop for k being the hash-keys in h using (hash-value v)
                  collect (print-hash-key-or-val k nil)
                  collect (print-hash-key-or-val v nil))))

     (defmacro lethash (keys h &body body)
       "Let form binding hash table entries to let variables names"
       (let ((ht (gensym)))
         `(let ((,ht ,h))
            (let ,(loop for key in keys
                     collect `(,key (gethash ,(make-keyword key) ,ht)))
              ,@body))))

     (defmacro with-keys (keys h &body body)
       "Make keys of hash table available to body for use & changable via setf"
       (let ((ht (gensym)))
         (loop for key in keys
            for newbody = (subst `(gethash ,(make-keyword key) ,ht) key body)
            then (subst `(gethash ,(make-keyword key) ,ht) key newbody)
            finally (return `(let ((,ht ,h))
                               ,@newbody)))))

     (defun linear-interpolation (ys xs x)
       "Linear interpolation: calculate y(x) at x given table of ys and xs. Also returns ind ex of lookup table interval. Works from first x to less than last x."
       (let* ((i (position x xs :test #'>= :from-end t))
              (x0 (elt xs i))
              (x1 (elt xs (1+ i)))
              (y0 (elt ys i))
              (y1 (elt ys (1+ i))))
         (+ y0 (* (- y1 y0) (- x x0) (/ (- x1 x0))))))

     (defun maptree (f tree)
       "Map a function on the leaves of a tree"
       (cond
         ((null tree) nil)
         ((atom tree) (funcall f tree))
         (t (cons (maptree f (car tree))
                  (maptree f (cdr tree))))))

     (defmethod diff ((l list))
       "Return list of the 1st differences of given list: l(1)-l(0),...,l(n)-l(n-1)"
         (loop for i below (1- (length l))
            for li in l
            collect (- (elt l (1+ i)) li)))

     (defmethod diff ((v vector))
       "Return vector of the 1st differences of given vector: v(1)-v(0),...,v(n)-v(n-1)"
       (let* ((n (length v))
              (v2 (make-array (1- n))))
         (dotimes (i (1- n))
           (setf (aref v2 i) (- (aref v (1+ i)) (aref v i))))
         v2))

     (defun slot-ref (obj slots)
       "Reference nested objects by a list of successive slot names. For example, (slot-ref  o 'foo 'bar 'baz) should return (slot-value (slot-value (slot-value o 'foo) 'bar) 'baz) "
       (cond
         ((atom slots) (slot-value obj slots))
         ((null (cdr slots)) (slot-value obj (car slots)))
         (t (slot-ref (slot-value obj (first slots)) (rest slots)))))

     (defun slot-ref-set (obj slots val)
       "Set nested object slot reference to new value"
       (cond
         ((atom slots) (setf (slot-value obj slots) val))
         ((null (cdr slots)) (setf (slot-value obj (car slots)) val))
         (t (slot-ref-set (slot-value obj (first slots)) (rest slots) val))))

     (defsetf slot-ref slot-ref-set)

     (defmacro bind-nested-slots (forms obj &body body)
       "For each form of (VAR SLOT1 SLOT2 ...) bind VAR to (NESTED-SLOT OBJ SLOT1 SLOT2 ...) "
       `(let ,(loop for form in forms
                 collect `(,(first form) (slot-ref ,obj ',(rest form))))
          ,@body))

     (defmacro defpfun (name args pargs &body body)
       "Define pandoric function given name, arguments, pandoric arguments,
     & body forms."
       `(setf (symbol-function ',name)
              (plambda ,args ,pargs
                       ,@body)))
   #+END_SRC

** Утилиты

   #+NAME: utility_file
   #+BEGIN_SRC lisp :tangle src/mod/hh/util.lisp :noweb tangle :exports code  :padline no :comments link
     (in-package #:moto)

     (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:33.0) Gecko/20100101 Firefox/33.0")

     (defparameter *cookies*
       (list "portal_tid=1291969547067-10909"
             "__utma=189530924.115785001.1291969547.1297497611.1297512149.377"
             "__utmc=3521885"))

     (setf *drakma-default-external-format* :utf-8)

     (defun get-headers (referer)
       `(
         ("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
         ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
         ("Accept-Charset" . "utf-8")
         ("Referer" . ,referer)
         ;; ("Cookie" . ,(format nil "~{~a; ~}" *cookies*))
         ("Cookie" . "ad20c=2; ad17c=2; __utma=48706362.2093251633.1396569814.1413985658.1413990550.145; __utmz=48706362.1413926450.142.18.utmcsr=vk.com|utmccn=(referral)|utmcmd=referral|utmcct=/im; email=avenger-f%40yandex.ru; password=30e3465569cc7433b34d42baeadff18f; PHPSESSID=ms1rrsgjqvm3lhdl5af1aekvv0; __utmc=48706362; __utmb=48706362.5.10.1413990550")
         ))

     (defmacro web (to ot)
       (let ((x-to (append '(format nil) to))
             (x-ot (append '(format nil) ot)))
         `(let ((r (sb-ext:octets-to-string
                    (drakma:http-request ,x-to
                                         :user-agent *user-agent*
                                         :additional-headers (get-headers ,x-ot)
                                         :force-binary t)
                    :external-format :utf-8)))
            r)))

     (defmacro fnd (var pattern)
       `(multiple-value-bind (all matches)
            (ppcre:scan-to-strings ,pattern ,var)
          (let ((str (format nil "~a" matches)))
            (subseq str 2 (- (length str) 1)))))

     (defun merge-plists (&rest plists)
       "Merge all the given plists into a new plist. The new plist has all
     the keys from each plist, with values of keys in later lists
     overriding the values of the same keys in earlier plists.
     No particular order of key/value pairs is guaranteed.
     E.g.:
     > (merge-plists '(:a 1 :b 2) '(:a 3 :c 4) '(:d 5))
     (:D 5 :C 4 :A 3 :B 2)"
     (let ((result (copy-list (first plists))))
       (dolist (plist (rest plists))
         (do* ((prop (first plist) (first plist))
               (value (second plist) (second plist))
               (oldpl plist plist)
               (plist plist (cddr plist)))
              ((not oldpl))
           (setf (getf result prop) value)))
       result))

     (defun contains (string pattern)
       (if (search pattern string)
           t))

     ;; eval-always

     (defmacro eval-always (&body body)
       "Wrap <_:arg body /> in <_:fun eval-when /> with all keys \(compile, load and execute) mentioned"
       `(eval-when (:compile-toplevel :load-toplevel :execute)
          ,@body))

     ;; #` syntax

     (eval-always
       (defun |#`-reader| (stream char arg)
         "Literal syntax for zero/one/two argument lambdas.
     Use @ as the function's argument, % as the second.
     Examples:
     CL-USER> #`(+ 2 @)
     \(lambda (&optional x y)
        (+ 2 x))
     CL-USER>  #`((1+ @) (print @))
     \(lambda (&optional x y)
        (1+ x)
        (print x))
     CL-USER> #`(+ 1 2)
     \(lambda (&optional x y)
        (+ 1 2))
     CL-USER>  #`(+ @ %)
     \(lambda (&optional x y)
        (+ x y))
     "
         (declare (ignore char arg))
         (let ((sexp (read stream t nil t))
               (x (gensym "X"))
               (y (gensym "Y")))
           `(lambda (&optional ,x ,y)
              (declare (ignorable ,x)
                       (ignorable ,y))
              ,@(subst y '%
                       (subst x '@
                              (if (listp (car sexp))
                                  sexp
                                  (list sexp)))))))
       ;; set #`
       (set-dispatch-macro-character #\# #\` #'|#`-reader|))


     ;; anaphoric

     (eval-always
      (defmacro if-it (test then &optional else)
        "Like IF. IT is bound to TEST."
        `(let ((it ,test))
           (if it ,then ,else))))

     (eval-always
      (defmacro when-it (test &body body)
        "Like WHEN. IT is bound to TEST."
        `(let ((it ,test))
           (when it
             ,@body))))

     (eval-always
      (defmacro and-it (&rest args)
        "Like AND. IT is bound to the value of the previous AND form."
        (cond ((null args) t)
              ((null (cdr args)) (car args))
              (t `(when-it ,(car args) (and-it ,@(cdr args)))))))

     (eval-always
      (defmacro dowhile-it (test &body body)
        "Like DOWHILE. IT is bound to TEST."
        `(do ((it ,test ,test))
             ((not it))
           ,@body)))

     (eval-always
      (defmacro cond-it (&body body)
        "Like COND. IT is bound to the passed COND test."
        `(let (it)
           (cond
             ,@(mapcar #``((setf it ,(car @)) ,(cadr @))
                       ;; uses the fact, that SETF returns the value set
                       body)))))
     ;; maybe


     (defmacro maybecall (val &rest funs)
       `(and-it ,val
                ,@(mapcar (lambda (fun)
                            `(funcall ,fun it))
                          funs)))

     (defmacro maybe (form)
       "Return a value, returned by a <_:arg form /> or nil, if <_:class error /> is signalled"
       `(restart-case
            (handler-bind ((error #'(lambda (c)
                                      (declare (ignore condition))
                                      (invoke-restart 'skip))))
              ,form)
          (skip () nil)))
   #+END_SRC

** Глобальные определения

   #+NAME: globals
   #+BEGIN_SRC lisp :tangle src/mod/hh/globals.lisp :noweb tangle :exports code :padline no :comments link
     (in-package #:moto)

     ;; clear db
     (drop '("profile" "vacancy"))
   #+END_SRC

** Сущности и автоматы

   Соберем все сущности и автоматы

   #+NAME: entity_and_automates
   #+BEGIN_SRC lisp :tangle src/mod/hh/entityes.lisp :noweb tangle :exports none :padline no :comments link
     (in-package #:moto)

     <<asm_profile()>>

     <<asm_vacancy()>>
   #+END_SRC

** Поисковые профили

    #+NAME: asm_profile
    #+BEGIN_SRC emacs-lisp :var flds=profile_flds :exports none
      (gen-entity "profile" "поисковые профили" flds)
    #+END_SRC

** Вакансии

    #+NAME: asm_vacancy
    #+BEGIN_SRC emacs-lisp :var flds=vacancy_flds states=vacancy_state :exports none
      (gen-automat "vacancy" "вакансии" flds states)
    #+END_SRC

* Экспертная система

  Предоставление рекомендаций и отбор вакансий на основе модифицируемых правил и фактах
  предметной области, таких как "работодатель - компания по разработке ПО" или "ИТ-поддержка
  не является приоритетом компании"

  Предсказание поведения (путей достижения целей) компании (в процессе найма и вне его) на
  основе моделей и целей.

  Выбор вариантов поведения в ответ на предьявляемые требования (цикл распознавание-действие
  в продукционной системе)

  Построение концептуальных моделей и преобразования в них - выбор стратегии действий и
  постановка целей

  Выбор способа представления знаний (правила, фреймы, концептуальные графы)

  Выбор стратегии поиска

** Правила

   Включение терма из набора технологий в заголовке вакансии - присвоение классификатора
   (тега)

   Анализ требований
   - Терм технологии
   - Степень владения

   Правила вывода - сопоставление с профилем

   Вычисление различий (дифф) требований и профильных навыков

   Интерактивное построение профиля (ответы на вопросы). Необходим видимый прогресс и
   предварительная классификация предложений

   Построение новых правил на основе известных

** Теория

   Состояние, Поведение, Отношение. Вывод

   Создание гипотезы, проверка гипотезы, построение следствий
=======
