#+HTML_HEAD: -*- fill-column: 92 -*-

#+TITLE: Модуль авторизации и аккаунтинга

#+NAME:css
#+BEGIN_HTML
<link rel="stylesheet" type="text/css" href="css/css.css" />
#+END_HTML

* Введение

  Как пользователь я хочу иметь возможность зарегистрироваться на сайте. Сразу после
  регистрации я хочу быть залогиненным в авторизованную сессию.

  Как пользователь, я хочу иметь возможность выйти из авторизованной сессии после окончания
  работы.

  Как пользователь, я хочу войти в авторизованную сессию по своему емейлу и паролю.

  Как разработчик, я хочу конфигурировать url-ы, на которые попадает пользователь при
  выполнении этого сценария и навешивать свои обработчики на события:
  - регистрация пользователя
  - успешный вход пользователя
  - неуспешный вход пользователя
  - выход пользователя

  Что нам для этого нужно?
  - Сущность =User=, имеющая поля =email= и =password=
  - Движок создания форм, функции которого определены не здесь

* Как это работает?
** Регистрация

  =При регистрации= пользователя контроллер регистрации должен вызвать создание пользователя
  (=create-user=), передав =name=, =password= и =email= пользователя.

  Обязанность проверки корректности данных лежит на контроллере. =create-user= просто
  создает пользователя, делает его залогиненным и возвращает числовой идентификатор
  пользователя.

  Этот идентификатор контроллер может использовать по собственному усмотрению, например
  занести в переменную сессии - при этом контроль за сессией - прерогатива контроллера.

  В случае, если по каким-то причинам (разве что отказ базы данных) не удалось создать
  пользователя - сигнализируется ошибка.

** Логин

  =При логине= пользователь вводит email и пароль, который передается контроллеру
  логина. Контроллер логина извлекает (=get-auth-data=) email и пароль, проверяет их
  (=check-auth-data=) и в случае успеха устанавливает переменную сессии =current-user= и
  вызывает =auth-success=. В случае неудачи вызывает =auth-fail=.

** Логаут

  =При логауте= пользователь посылает запрос на логаут, контроллер вызывает =logout-user= и
  обнуляет переменную сессии =current-user=

  TODO: Забыл пароль и восстановление пароля

* Шаблоны
  Соберем шаблоны логина и логаута

  #+NAME: auth_tpl
  #+BEGIN_SRC closure-template-html :tangle src/mod/auth/auth-tpl.htm :noweb tangle :exports code
    // -*- mode: closure-template-html; fill-column: 140 -*-
    {namespace authtpl}

    {template logintpl}
      <<loginform_tpl>>
    {/template}

    {template logouttpl}
      <<logoutform_tpl>>
    {/template}
  #+END_SRC

* Функционал

  Соберем контроллеры и все функции, которые контроллеры вызывают

  #+NAME: auth_fn
  #+BEGIN_SRC lisp :tangle src/mod/auth/auth.lisp :noweb tangle :exports code
    (in-package #:moto)

    ;; Скомпилируем шаблон
    (closure-template:compile-template
     :common-lisp-backend
     (pathname
      (concatenate 'string *base-path* "mod/auth/auth-tpl.htm")))

    <<auth_fn_contents>>

    <<auth_test>>
  #+END_SRC

  Мы вводим:

** Шаблон логина

   #+NAME: loginform_tpl
   #+BEGIN_SRC html :exports code
     <form method="POST" name="loginform">
         <input type="text" id="login" name="login" />
         <input type="password" id="password" name="password" />
         <input type="submit" />
     </form>
   #+END_SRC

** Шаблон логаута

   #+NAME: logoutform_tpl
   #+BEGIN_SRC html :exports code
     <form method="POST" name="logoutform">
         <input type="hidden" name="logout" value="logout" />
         <input type="submit" value="logout" />
     </form>
   #+END_SRC

** Событие создания пользователя

   #+NAME: auth_fn_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     ;; Событие создания пользователя
     (defun create-user (name password email)
       "Создание пользователя. Возвращает id пользователя"
       (aif (make-user :name name :password password :email email :ts-create (get-universal-time) :ts-last (get-universal-time))
            (progn
              ;; (dbg "Создан пользователь: ~A" (id it))
              ;; Делаем его залогиненным
              (upd-user (get-user (id it)) (list :state ":LOGGED"))
              ;; Возвращаем user-id
              (id it))
            (err 'err-create-user)))
   #+END_SRC

** Событие выхода пользователя из системы

   #+NAME: auth_fn_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     ;; Событие выхода
     (defun logout-user (current-user)
       (takt (get-user current-user) :unlogged))
   #+END_SRC

** Обобщенный метод извлечения авторизационных данных

   В простейшем случае данные из объекта =request=, но возможны и другие варианты,
   поэтому этот обобщенный метод специфицируется объектом, из которого извлекаются данные.

   #+NAME: auth_fn_contents
   #+BEGIN_SRC lisp

     ;; Извлечение авторизационных данных
     (defmethod get-auth-data ((request list))
       (alist-to-plist request))
   #+END_SRC

** Функция проверки авторизационных данных - в простейшем случае логина и пароля

   Функция принимает в качестве параметра plist, который должен содержать =email= и
   =password= введенный пользователем.

   Функция проверяет, есть ли пользователь с этим email-ом и паролем и если есть -
   возвращает его id. Если нет - возвращает nil.

   #+NAME: auth_fn_contents
   #+BEGIN_SRC lisp

     ;; Проверка авторизационных данных
     (defun check-auth-data (auth-data)
       (let ((result (find-user :email (getf auth-data :email) :password (getf auth-data :password))))
         (if (null result)
             nil
             (id (car result)))))
   #+END_SRC

** Событие успешного входа пользователя в систему

   #+NAME: auth_fn_contents
   #+BEGIN_SRC lisp
     (in-package #:moto)

     ;; Событие успешного входа
     (defun login-user-success (id)
       (let ((u (get-user id)))
         (when (equal ":LOGGED" (state u))
           (upd-user u (list :state ":UNLOGGED")))
         (takt u :logged)))
   #+END_SRC

** Событие неуспешного входа пользователя в систему

   #+NAME: auth_fn_contents
   #+BEGIN_SRC lisp

     ;; Событие неуспешного входа
     (defun login-user-fail ()
       "Wrong auth"
       )
   #+END_SRC

** TODO Забыл пароль
** TODO Javascript для форм, необязательно
** TODO Функцию проверки залогинен ли пользователь

   Создадим функцию, которая проверяет залогинен ли пользователь

   #+NAME: is-logged
   #+BEGIN_SRC lisp :exports code
     ;; (defun is-logged (request)
     ;;   ( (session-value current-user
   #+END_SRC

** TODO Функцию проверки прав пользователя на доступ к какому-то объекту
* Тесты

  Теперь у нас есть весь необходимый функционал, для работы авторизации. Мы можем его
  протестировать, для этого сформируем тест:

  #+NAME: auth_test
  #+BEGIN_SRC lisp

    ;; Тестируем авторизацию
    (defun auth-test ()
      <<auth_test_contents>>
      (dbg "passed: auth-test~%"))
    (auth-test)
  #+END_SRC

  #+NAME: auth_test_contents
  #+BEGIN_SRC lisp
    (in-package #:moto)

    ;; Зарегистрируем пользователя
    ;; (let* ((name "admin")
    ;;        (password "tCDm4nFskcBqR7AN")
    ;;        (email "nomail@mail.ru")
    ;;        (new-user-id (create-user name password email)))
    ;;   ;; Проверим что он существует
    ;;   (assert (get-user new-user-id))
    ;;   ;; Проверим, что он залогинен
    ;;   (assert (equal ":LOGGED" (state (get-user new-user-id))))
    ;;   ;; Выход пользователя из системы
    ;;   (logout-user new-user-id)
    ;;   ;; Проверим, что он разлогинен
    ;;   (assert (equal ":UNLOGGED" (state (get-user new-user-id))))
    ;;   ;; Логин пользователя в систему
    ;;   (let ((logged-user-id))
    ;;     (aif (check-auth-data (get-auth-data (list (cons 'email email)
    ;;                                                (cons 'password password))))
    ;;          (progn
    ;;            (login-user-success it)
    ;;            (setf logged-user-id it))
    ;;          (login-user-fail))
    ;;     ;; Проверим, что успешно залогинился
    ;;     (assert (equal ":LOGGED" (state (get-user logged-user-id))))
    ;;     ;; Сновa выход
    ;;     (logout-user logged-user-id))
    ;;   ;; Попытка логина с неверными credentials
    ;;   (let ((logged-user-id))
    ;;     (aif (check-auth-data (get-auth-data (list (cons 'email email)
    ;;                                                (cons 'password "wrong-password"))))
    ;;          (progn
    ;;            (login-user-success it)
    ;;            (setf logged-user-id it))
    ;;          (login-user-fail))
    ;;     ;; Проверим, что не удалось успешно залогиниться
    ;;     (assert (equal nil logged-user-id))))
  #+END_SRC
